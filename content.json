{"meta":{"title":"Mr WhiteSike's Blog","subtitle":"不鸣则已，一飞冲天","description":null,"author":"Mr WhiteSike","url":"http://zhifeiyuntian.com","root":"/"},"pages":[{"title":"Language","date":"2019-02-28T06:45:44.000Z","updated":"2019-02-28T06:45:44.038Z","comments":true,"path":"Language/index.html","permalink":"http://zhifeiyuntian.com/Language/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-03-02T13:28:10.000Z","updated":"2019-03-02T13:28:10.817Z","comments":true,"path":"archives/index.html","permalink":"http://zhifeiyuntian.com/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-02T09:17:00.000Z","updated":"2019-03-02T09:22:42.923Z","comments":true,"path":"about/index.html","permalink":"http://zhifeiyuntian.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-03T14:38:10.781Z","updated":"2019-03-03T14:38:10.781Z","comments":true,"path":"categories/index.html","permalink":"http://zhifeiyuntian.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-05T14:18:55.060Z","updated":"2019-03-05T14:18:55.060Z","comments":true,"path":"tags/index.html","permalink":"http://zhifeiyuntian.com/tags/index.html","excerpt":"","text":""},{"title":"life","date":"2019-02-28T06:55:51.000Z","updated":"2019-02-28T06:55:51.560Z","comments":true,"path":"life/index.html","permalink":"http://zhifeiyuntian.com/life/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础 （二）List","slug":"arraylist","date":"2019-03-08T03:40:12.000Z","updated":"2019-03-18T05:39:47.737Z","comments":true,"path":"2019/03/08/arraylist/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/08/arraylist/","excerpt":"前言今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。 ArrayList介绍ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable","text":"前言今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。 ArrayList介绍ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从上边源码可以看到，ArrayList继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口 * 继承AbstractList，实现List：提供了相关的添加、删除、修改、遍历等 * 实现RandomAccess接口：提供了快速随机访问功能，即可以通过元素下标快速获取元素对象 * 实现Cloneable接口：重写函数clone()，提供被克隆功能 * 实现java.io.Serializable：使ArrayList支持序列化的功能，能够通过序列化去传输。 ArrayList中的操作非线程安全的，建议在单线程中使用，在多线程中可以使用CopyOnWriteArrayList。 ArrayList源码分析成员变量12transient Object[] elementData; // non-private to simplify nested class accessprivate int size; 这两句源码，可以看出：ArrayList包含了两个重要的对象elementData和size。 * Object[] elementData，它保存添加到ArrayList中的元素。是个动态数组。 * size是ArrayList中元素的实际个数 构造函数12345678910111213141516171819202122232425262728293031323334// 默认容量大小private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 给定初始容量大小的构造函数public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125;// 初始容量为10的默认构造函数public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;// 创建一个包含Collection的ArrayListpublic ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; add方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 方式1public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;其中的类内部方法ensureCapacityInternal：private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;// 方式2public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;// 方式3public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;// 方式4public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 方式1：在列表末尾插入值 * 首先进行扩容的校验 * 将值插入下标为size的位置，然后size++（就是实际大小加一） 方式2：在指定位置插入值 * 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常 * 接着进行扩容校验 * 将值插入到下标为index的位置，然后size++ 方式3：在列表末尾插入Collection * Collection调用toArray(),转化为Object[] 数组 * 获取数组长度numNew * 根据size + numNew的值进行扩容校验 * 将Collection转化的数组拼接到elementData的末尾 * size += numNew 方式4：在指定位置插入Collection * 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常 * Collection调用toArray(),转化为Object[] 数组a * 获取数组长度numNew * 根据size + numNew的值进行扩容校验 * 判断numMoved &gt; 0（numMoved = size - index）， 为真：拷贝原数组中index后所有元素，到新数组中的index+numNew以及后面的位置 * 拷贝数组a所有元素按之前排列顺序到数组elementData中的[index,index+numNew-1]位置 * size += numNew remove方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102方式1：按索引删除元素public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;方式2：根据值删除列表中某个元素public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125;方式3：将列表中元素全部清除public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125;方式4：删除两个列表中的交集部分public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125;方式5：按照一定规则过虑集合中的元素public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; set方法1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; get方法12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 其他方法 序号 方法 说明 1 public Object clone() 将一个list拷贝一份到新的list中 2 public boolean contains(Object o) 判断list中是否包含某个对象实例 3 public void forEach(Consumer&lt;? super E&gt; action) JDK1.8新增的forEach遍历元素方法参考 4 public int indexOf(Object o) 获取某个实例对象第一次出现的位置下标 5 public boolean isEmpty() 判断是否为空 6 public Iterator iterator() 获取Iterator迭代器 7 public int lastIndexOf(Object o) 获取某个实例对象最后一次出现的位置下标 8 public ListIterator listIterator() 获取ListIterator迭代器 9 public ListIterator listIterator(int index) 获取指针指向index的ListIterator迭代器 10 public void replaceAll(UnaryOperator operator) 11 public boolean retainAll(Collection&lt;?&gt; c) 获取两个集合中交集 12 public int size() 获取list的元素个数 13 public void sort(Comparator&lt;? super E&gt; c) 按比较器c的方式进行排序 14 public Spliterator spliterator() 主要用来多线程并行迭代的迭代器Spliterator，JDK1.8新增方法参考 15 public List subList(int fromIndex, int toIndex) 截取子List 16 public Object[] toArray() 将List转化为Object[]数组，如果将Object[]数组转换成其他类型，会抛出ClassCastException异常，因为Java不支持乡下转型。 17 public T[] toArray(T[] a) 传入一个数组作为参数，并通过泛型T的方式定义参数，所返回的数组类型就是调用集合的泛型，所以自己无需在转型；根据传入数组的长度，与集合的实际长度的关系：a，数组长度不小于集合长度，直接拷贝，不会产生新的数组对象；b，数组长度小于集合长度，会创建一个与集合长度相同的新数组，将集合的数据拷贝到新数组并将新数组的引用返回 ArrayList遍历方式方式1：通过迭代器遍历1234Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; iterator.next();&#125; 方式2：通过索引值遍历，随机访问123for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i);&#125; 方式3：通过forEach1234Integer value = null;for (Integer integer : list) &#123; value = integer;&#125; 方式4：通过forEach方法123456list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; ; &#125;&#125;); 通过一个实例，来测试一下这几种方式的遍历速率：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TestArrayListAccess &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000000; i++) &#123; list1.add(i); &#125; // 方式1 iteratorTest(list1); // 方式2 randomAccessTest(list1); // 方式3 forEachTest(list1); // 方式4 forEachTest1(list1); &#125; // iterator方式 public static void iteratorTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;Iterator耗时：&quot; + interval +&quot;ms&quot;); &#125; // 随机访问方式 public static void randomAccessTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;随机访问耗时：&quot;+ interval + &quot;ms&quot;); &#125; // forEach方式 public static void forEachTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (@SuppressWarnings(&quot;unused&quot;) Integer integer : list) &#123; ; &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;forEach访问耗时：&quot;+ interval + &quot;ms&quot;); &#125; // 调用List的forEach方法 public static void forEachTest1(List&lt;Integer&gt; list) &#123; long startTime = System.currentTimeMillis(); list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; ; &#125; &#125;); long endTime = System.currentTimeMillis(); System.out.println(&quot;forEach 方法耗时：&quot; + (endTime-startTime) + &quot;ms&quot;); &#125; &#125; 运行结果： Iterator耗时：5ms随机访问耗时：4msforEach访问耗时：7msforEach 方法耗时：7ms 从上边结果可以看出，遍历ArrayList时，使用索引遍历访问的时候效率最高，而使用其他方式时，效率偏低。 总结本文介绍了ArrayList，其中包括其构造函数和方法以及它们的源码解析，最后介绍了ArrayList的遍历方式，并且通过一个实例，比较了这几种遍历方式的效率。 寄语希望这篇文章能够给大家带来一点帮助！我的口号是：我分享，我快乐，越分享，越快乐！感谢各位老铁的支持。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://zhifeiyuntian.com/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://zhifeiyuntian.com/tags/集合/"}]},{"title":"Java基础 （一）字符串","slug":"string","date":"2019-03-05T23:54:54.000Z","updated":"2019-03-18T05:39:00.584Z","comments":true,"path":"2019/03/06/string/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/06/string/","excerpt":"前言字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。","text":"前言字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。 1、String构造函数 序号 构造函数 说明 1 public String() 构造空字符String对象 2 public String(String original) 构造一个新的相同的String对象 3 public String(char value[]) 通过给定字符数组，构造String对象 4 public String(char value[], int offset, int count) 给定字符数组，通过下标偏移量（offset），截取量（count）截取子数组，构建包含此子数组的String对象 5 String(int[] codePoints, int offset, int count) 给定int数组，通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 6 public String(byte bytes[]) 使用平台默认的字符集解码指定的byte数组，构造String 对象 7 public String(byte bytes[], int offset, int length) 通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 8 public String(byte bytes[], String charsetName) 通过字符集名字（charsetName）确定字符集，然后利用此字符集解码指定的byte数组，构建String对象 9 public String(byte bytes[], int offset, int length, String charsetName) 通过下标偏移位置（offset），截取量（count）截取子数组，通过字符集名字确定字符集，利用此字符集解码指定的byte子数组，构建String对象 10 public String(byte bytes[], Charset charset) 利用字符集charset解码指定的byte数组，构建String对象；jdk1.6新增 11 public String(byte bytes[], int offset, int length, Charset charset) 通过下标偏移位置（offset），截取量（count）截取子数组，然后利用字符集charset解码指定的byte子数组，构建String对象；jdk1.6新增 12 public String(StringBuffer buffer) 通过给定的StringBuffer，构建String对象 13 public String(StringBuilder builder) 通过给定的StringBuffer，构建String对象 2、常见的String方法函数 序号 方法函数 说明 1 public int length() 获取字符串长度 2 public boolean isEmpty() 判断字符串是否为空 3 public char charAt(int index)) 获取下标index下的字符 4 public byte[] getBytes() 将字符串转换成字节数组 5 public byte[] getBytes(String charsetName) 通过指定字符集名字将字符串转换成字节数组 6 public byte[] getBytes(Charset charset)) 通过指定字符集将字符串转换成字节数组 7 public boolean equals(Object anObject) 判断两个对象中字符是否都相同 8 public boolean contentEquals(StringBuffer sb)) 判断字符串对象和StringBuffer中内容是否相同 9 public boolean equalsIgnoreCase(String anotherString) 判断与另一个给定的字符串对象忽略大小写后的内容是否相同 10 public int compareTo(String anotherString) 与另一个字符串对象比较大小 11 public int indexOf(String str) 查找指定子串在字符串中第一次出现的位置下标 12 public int indexOf(String str, int fromIndex) 指定从起始下标位置开始查找指定子串在字符串中第一次出现的位置下标 13 public String substring(int beginIndex) 截取从起始下标位置开始到字符串末尾的子串 14 public String substring(int beginIndex, int endIndex) 截取从起始下标位置开始到（结束下标位置-1）的子串 15 public String concat(String str) 两个字符串拼接 16 public String replace(char oldChar, char newChar) 用newChar替换字符串中出现的oldChar 17 public boolean matches(String regex) 正则表达式匹配，匹配成功返回true，匹配失败返回false 18 public String[] split(String regex) 字符串在regex出现的地方进行分割，转换成字符串数组 19 public String[] split(String regex, int limit) 字符串在regex出现的地方进行分割，limit为分割的次数，分割成字符串数组，长度=limit+1 20 public String toLowerCase() 字符串中大写字母全部变成小写字母 21 public String toUpperCase() 字符串中小写字母全部变成大写字母 22 public String trim() 去除字符串首尾两端的空白字符 23 public char[] toCharArray() 字符串转化成字符数组 24 public static String valueOf(Object obj) 其他对象转化成字符串，静态方法，使用方式：String.valueOf(obj) 25 public static String join(CharSequence delimiter, CharSequence… elements) 字符串拼接，jdk1.8新增 3、== 和 equals 两者之间的区别3.1、==比较对于基本类型和引用类型==的作用效果是不同的： * 基本类型：比较的是值是否相同 * 引用类型：比较的是引用是否相同 3.2、equals比较equals本质上就是==，只不过String类重写了equals方法，源码如下：123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 从源码中可以看出，当是引用比较的时候改成了值比较。 示例代码：1234567String s1 = &quot;hello&quot;;String s2 = &quot;hello&quot;;String s3 = new String(&quot;hello&quot;);System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // falseSystem.out.println(s1.equals(s2)); // trueSystem.out.println(s1.equals(s3)); // true 字符串对象的创建过程：String类在内存中管理着一个字符串常量池，池中所有相同的字符串常量只占用同一个内存空间。 * String s1 = &quot;hello&quot;;执行这句代码时，程序会先看常量池中是否有“hello”这个字符串常量，如果没有就创建一个“hello”字符串对象，并且让引用s1指向这个对象；如果有，让引用s1直接指向常量池中已经存在的hello对象。 * String s3 = new String(&quot;hello&quot;);而执行这句代码时，重复s1的操作，然后执行new String() ,重新在堆中开辟了一个内存空间，将常量池中的hello对象复制一份到这个内存空间中，让引用s3指向堆中这个刚创建的hello对象。 4、StringBuffer和StringBuilder的区别4.1、相同点* 可增长，可改写 * 提供了字符串的许多其他功能 4.2、不同点* StringBuffer是线程同步的，意味着它是线程安全的，但是牺牲了对字符串操作的性能 * StringBuilder不是同步的，意味着它是线程不安全的，但是具有更快的字符串操作性能 5、StringJoiner类Java开发中，有时候会遇到字符串拼接的操作，你可能会直接想到就是使用 + 这个操作符直接进行拼接，或者使用StringBuilder或者StringBuffer来实现，那么还有一种重要的拼接方式，就是Java8中提供的StringJoiner，还不了解这种拼接方式的童鞋，那我们就来共同学习一下这个字符串拼接类！ 5.1、StringJoiner类的构造函数12345678910111213141516public StringJoiner(CharSequence delimiter) &#123; this(delimiter, &quot;&quot;, &quot;&quot;);&#125;public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // make defensive copies of arguments this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;&#125; StringJoiner类共有上面2个构造函数，从上面可以看出，第一个构造函数就是调用第二个构造函数，那么我们就来分析一下第二个构造函数，其中delimiter这个参数表示字符串进行拼接的时候以delimiter作为分隔符，prefix代表字符串拼接后的前缀，suffix代表字符串拼接后的后缀。 StringJoiner的用法比较简单 示例代码： 12345678public class TestJoiner &#123; public static void main(String[] args) &#123; StringJoiner sJoiner = new StringJoiner(&quot;,&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;); sJoiner.add(&quot;hello&quot;); sJoiner.add(&quot;world&quot;); System.out.println(sJoiner.toString()); &#125;&#125; 以上代码输出结果： 1&#123;hello,world&#125; 5.2、常用的add方法123456789101112public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this;&#125;private StringBuilder prepareBuilder() &#123; if (value != null) &#123; value.append(delimiter); &#125; else &#123; value = new StringBuilder().append(prefix); &#125; return value;&#125; StringJoiner其实就是依赖StringBuilder实现的 看到这，有些童鞋可能会产生一个疑问，不是已经有StringBuilder了，为什么Java8中还要定义一个StringJoiner呢？ 现在有一个需求：如果我们有这样一个List，这个List中呢，有“hello”，“world”， 想要把它拼接成一个以下形式的字符串： 1hello:world 方式一：使用StringBuilder实现 12345678StringBuilder builder = new StringBuilder();if(!list.isEmpty()) &#123; builder.append(list.get(0)); for (int i = 1; i &lt; list.size(); i++) &#123; builder.append(&quot;:&quot;).append(list.get(i)); &#125;&#125;System.out.println(builder.toString()); 方式二：使用stream()实现 1list.stream().reduce(new StringBuilder(),(sb, s)-&gt;sb.append(s).append(&quot;:&quot;),StringBuilder::append).toString(); 输出结果： 1hello:world: 这种方式需要进行二次处理 方式三：使用操作符+实现 12345678String sum_string = &quot;&quot;;if(!list.isEmpty()) &#123; sum_string += list.get(0); for (int i = 1; i &lt; list.size(); i++) &#123; sum_string +=&quot;:&quot;+list.get(i); &#125;&#125;System.out.println(sum_string); 以上几种方式，要么是代码复杂，要么是性能不高。 如果使用StringJoiner，一行代码就可以搞定： 1list.stream().collect(Collectors.joining(&quot;:&quot;)); 其中，Collectors.joining()的源代码： 1234567891011public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123; return joining(delimiter, &quot;&quot;, &quot;&quot;); &#125;public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; return new CollectorImpl&lt;&gt;( () -&gt; new StringJoiner(delimiter, prefix, suffix), StringJoiner::add, StringJoiner::merge, StringJoiner::toString, CH_NOID); &#125; joining方法的实现原理就是借助了StringJoiner。 如果改变需求，在拼接后的字符串添加前缀“{”，和后缀“}”，那么StringJoiner的优势就会很明显了。 需要注意的一点是： StringJoiner是通过StringBuilder实现的，也就是说它也是非线程安全的。 日常开发中，需要进行字符串拼接，如何选择？ * 如果是简单字符串拼接，直接使用+即可 * 如果是在for循环中进行字符串拼接，考虑使用StringBuilder或者StringBuffer。 * 如果是通过一个集合，例如list，进行拼接考虑使用StringJoiner 总结字符串在Java开发中应用非常广泛，熟练掌握能避免一些不必要的坑！ 寄语希望这篇文章能给大家带来一点帮助，如果文章中有哪些错误之处，还请批评指正！我的口号是：我分享，我快乐，越分享，越快乐！感谢各位老铁的支持。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://zhifeiyuntian.com/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhifeiyuntian.com/tags/Java/"},{"name":"String","slug":"String","permalink":"http://zhifeiyuntian.com/tags/String/"}]},{"title":"第一次总结","slug":"interview","date":"2019-03-05T07:32:33.000Z","updated":"2019-03-18T05:34:03.081Z","comments":true,"path":"2019/03/05/interview/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/05/interview/","excerpt":"前言 创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。","text":"前言 创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。 进步 学习了一些新技能： * 熟悉了Markdown语法 * 利用阿里云解析了GitHub和coding里的Pages服务 * HEXO和主题配置 主题配置 站点配置文件_config.yml：123456789101112131415161718192021222324252627282930313233343536373839# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/# 搜索search: path: search.xml field: post format: html limit: 10000#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #type: git type: git repo: github: git@github.com:MrWhiteSike/MrWhiteSike.github.io.git,master coding: git@git.coding.net:MrWhiteSike/MrWhiteSike.git,master 主题配置文件/themes/next/_config.yml:参考了这篇博文，具体配置细节还请自己琢磨 结束 做这个博客呢，愿景有二： * 记录生活中的点滴故事 * 分享知识，提升技能","categories":[{"name":"总结","slug":"总结","permalink":"http://zhifeiyuntian.com/categories/总结/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhifeiyuntian.com/tags/生活/"}]},{"title":"开篇博客","slug":"firstpaper","date":"2019-03-01T00:26:29.000Z","updated":"2019-03-18T08:00:36.575Z","comments":true,"path":"2019/03/01/firstpaper/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/01/firstpaper/","excerpt":"开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！","text":"开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！ 大概花了几天时间利用HEXO框架搭建了这个博客，建好之后心情还有点小激动，毕竟经过自己的一番努力，终于实现拥有专属于自己的个人博客网站，这里参考了hexo史上最全搭建教程，感谢这篇文章的博主，写的如此清晰，才让我如此快速的搭建起个人博客网站。 俗话说：万事开头难。但是只要相信，勇于实践，锲而不舍，方能成功。只要开始，我们不可半途而废，越过山丘，我们才能看到山后的另一番景象！ 先写这么多吧，来日方长！","categories":[{"name":"生活","slug":"生活","permalink":"http://zhifeiyuntian.com/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://zhifeiyuntian.com/tags/随笔/"}]}]}