{"meta":{"title":"Mr WhiteSike's Blog","subtitle":"不鸣则已，一飞冲天","description":null,"author":"Mr WhiteSike","url":"http://zhifeiyuntian.com","root":"/"},"pages":[{"title":"Language","date":"2019-02-28T06:45:44.000Z","updated":"2019-02-28T06:45:44.038Z","comments":true,"path":"Language/index.html","permalink":"http://zhifeiyuntian.com/Language/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-02T09:17:00.000Z","updated":"2019-03-02T09:22:42.923Z","comments":true,"path":"about/index.html","permalink":"http://zhifeiyuntian.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-03T14:38:10.781Z","updated":"2019-03-03T14:38:10.781Z","comments":true,"path":"categories/index.html","permalink":"http://zhifeiyuntian.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-03-02T13:28:10.000Z","updated":"2019-03-02T13:28:10.817Z","comments":true,"path":"archives/index.html","permalink":"http://zhifeiyuntian.com/archives/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-05T14:18:55.060Z","updated":"2019-03-05T14:18:55.060Z","comments":true,"path":"tags/index.html","permalink":"http://zhifeiyuntian.com/tags/index.html","excerpt":"","text":""},{"title":"life","date":"2019-02-28T06:55:51.000Z","updated":"2019-02-28T06:55:51.560Z","comments":true,"path":"life/index.html","permalink":"http://zhifeiyuntian.com/life/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP/IP协议，http协议等相关概念的学习","slug":"http","date":"2019-11-12T14:25:05.000Z","updated":"2019-11-13T02:05:37.704Z","comments":true,"path":"2019/11/12/http/","link":"","permalink":"http://zhifeiyuntian.com/2019/11/12/http/","excerpt":"TCPTCP是什么TCP（Transfer Control Protocol，传输控制协议），简称TCP协议，是一种面向连接的、可靠的、基于字节流的运输层通信协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两socket之间必须建立连接，以便在TCP协议的基础上进行通信，一旦这两个socket连接起来，就可以进行双向数据传输，双方都可以进行发送或接收操作。","text":"TCPTCP是什么TCP（Transfer Control Protocol，传输控制协议），简称TCP协议，是一种面向连接的、可靠的、基于字节流的运输层通信协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两socket之间必须建立连接，以便在TCP协议的基础上进行通信，一旦这两个socket连接起来，就可以进行双向数据传输，双方都可以进行发送或接收操作。 三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认并交换TCP窗口大小信息。 1、第一次握手：Client端将标志位SYN置为1，随机产生一个seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 2、第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack（number）= x + 1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 3、第三次握手：Client收到确认后，检查ACK是否为Client发送的seq+1，即x+1；如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server。Server检查ack是否为Server发送的seq+1，即y+1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手。 为什么要三次握手呢？ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。比如，Client发送的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间的滞留了，以致延误到连接释放以后的某个时间才到达Server，本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文段后，就误认为是Client再次发出的一个新的连接请求，于是就向Client发出确认报文段，同意建立连接。假设不采用 “三次握手” ，那么只要Server发出确认，新的连接就被认为建立了。由于现在Client并没有发送建立连接的请求，因此不会理睬Server的确认，也不会向Server发送数据。但Server确以为新的数据连接已经建立，并一直等待Client发送来数据。这样，Server的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。 四次分手当Client和Server通过三次握手建立TCP连接以后，数据传送完毕，肯定要断开TCP连接，那对于TCP的断开连接，这里就有了四次挥手。 1、第一次挥手：Client设置seq=x，向Server发送一个FIN报文段；此时，Client进入FIN_WAIT_1状态；表示Client没有数据要发送给服务端了。 2、第二次挥手：Server收到了Client发送的FIN=1，向Client回复ACK=1，ack=seq+1=x+1，然后Server端进入CLOSE_WAIT状态，Client进入FIN_WAIT_2状态；Server告诉Client，在等待自己去关闭连接； 3、第三次挥手：Server向Client发送FIN=1，seq=y，请求关闭连接，同时Server进入LAST_ACK状态； 4、第四次挥手：Client收到Server发送的FIN，向Server发送ACK=1，ack=seq+1=y+1，然后Client进入TIME_WAIT状态；Server收到ACK报文段后，就关闭连接；此时，Client等待2MSL后依然没有收到回复，则证明Server端已正常关闭，Client端也关闭连接。 为什么要四次挥手呢？ TCP是全双工模式，当客户端发出FIN报文段时，表示客户端没有数据要发送了，告诉服务端它的数据已经全部发送完毕了，这时客户端还可以接受来自服务端的数据。当服务端返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的。当服务端也发送了FIN报文段时，这时表示服务端也没有数据要发送了，也就是告诉客户端它也没有数据要发送了，当客户端返回ACK报文段时，表示它已经知道服务端也没有数据要发送了，服务端就会进入CLOSED状态，也就表示中断了这次TCP连接。 UDPUDP是什么？UDP（User Datagram Protocol），是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，在网络上以任何可能的路径传往目的地，但是能否到达目的地，到达目的地的时间和内容的正确性都是不能被保证的。 TCP和UDP的区别 TCP UDP TCP面向连接的通信服务 UDP面向无连接的通信服务 TCP提供可靠的通信传输 UDP不可靠，会丢包 TCP保证数据的顺序性 UDP不保证数据的顺序性 TCP数据无边界 UDP有边界 TCP速度慢 UDP速度快 TCP面向字节流 UDP面向报文 TCP一对一 UDP可以一对一，一对多 TCP报头至少20字节 UDP报头8字节 TCP有流量控制，拥塞控制 UDP没有 为什么UDP比TCP快1、TCP需要三次握手 2、TCP有拥塞控制，流量控制等机制 3、对数据内容正确性的校验必然占用计算机的处理时间和网络带宽 因此TCP传输效率不如UDP高。 为什么TCP比UDP可靠1、TCP是面向连接的，建立连接之后才发送数据；而UDP则不管对方存不存在都会发送数据。 2、TCP有确认机制，接收端每收到一个正确包都会回应给发送端。超时或者数据包不完整的话发送端会重传。UDP没有这种确认机制，因此可能会丢包。 HTTPHTTP是什么HTTP协议（Hypertext Transfer Protocol，超文本传输协议）,是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，是Web联网的基础，建立在TCP协议之上的一种应用。 HTTP最显著的特点是：客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接，从建立连接到关闭连接的过程，就称为一次连接。 一次完整的HTTP请求所经历的7个步骤1、建立TCP/IP连接 在HTTP开始之前，客服端和服务器通过TCP三次握手建立连接 2、客户端向服务器发送HTTP请求行 3、客户端发送请求头和请求体，最后客户端会发送一空白行表示客户端请求完毕 4、服务器应答响应行，表示对客户端请求的应答 5、服务器向客户端发送响应头信息，最后会发送一个空白行来表示头信息的发送到此结束 6、服务器向客户端发送响应包，这个响应包就是所要请求的实际数据 7、服务器关闭TCP连接 总结对TCP，UDP以及HTTP等的相关概念进行了学习和总结，还有什么是三次握手，四次挥手，以及TCP协议这样设计的目的是什么；UDP和TCP之间的区别是什么；HTTP请求所要经历的7个步骤有哪些等内容，进行了一一阐述。","categories":[{"name":"协议","slug":"协议","permalink":"http://zhifeiyuntian.com/categories/协议/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://zhifeiyuntian.com/tags/Http/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://zhifeiyuntian.com/tags/TCP-IP/"}]},{"title":"HashMap常用API总结","slug":"hashmap","date":"2019-11-11T03:25:29.000Z","updated":"2019-11-11T07:31:00.708Z","comments":true,"path":"2019/11/11/hashmap/","link":"","permalink":"http://zhifeiyuntian.com/2019/11/11/hashmap/","excerpt":"前言HashMap是大家工作中用的比较多的容器类，由key-value键值对组成，那么今天我们就来看看这个容器类中都有哪些API！","text":"前言HashMap是大家工作中用的比较多的容器类，由key-value键值对组成，那么今天我们就来看看这个容器类中都有哪些API！ Java8前 HashMap里经常使用的API 序号 方法 说明 1 public V put(K key, V value) 添加key-value类型数据 2 public void putAll(Map&lt;? extends K, ? extends V&gt; m) 把另一个Map容器中的所有数据添加本容器中 3 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取Map容器中所有的包含key和value的Entry对象，返回一个Set集合 4 public Set keySet() 获取Map容器中所有的key，返回一个Set集合 5 public Collection values() 获取Map容器中所有的value值，返回Collection集合 6 public V get(Object key) 根据key值，获取value值 7 public V remove(Object key) 根据key值，删除key-value键值对 8 public boolean remove(Object key, Object value) 根据key-value值，删除数据 9 public void clear() 清空容器中所有的数据 10 public boolean containsKey(Object key) 判断容器中是否包含某个key 11 public boolean containsValue(Object value) 判断容器中是否包含某个value值 12 public boolean isEmpty() 判断容器是否为null 13 public int size() 获取容器中的数据个数 Java8 HashMap里新增的API 序号 方法 说明 1 public V putIfAbsent(K key, V value) key不存在才put，存在就跳过 2 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) 如果key存在，则执行lambda表达式（例如，(oldval,newVal)-&gt;(Integer)oldval+(Integer)newVal），表达式入参为oldVal和newVal（就是merge方法的第二个参数值），表达式返回最终put的val。如果key不存在，则直接put newVal 3 public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) 如果key存在，则执行lambda表达式（例如，(k,oldVal)-&gt; oldVal +”1”），表达式入参为k和oldVal；如果key不存在，那么oldVal为null，那么lambda中涉及到oldVal的计算会报空指针异常。 4 default V computeIfAbsent(K key,Function&lt;? super K, ? extends V&gt; mappingFunction) 如果key存在，直接返回当前value值；如果key不存在，执行lambda表达式（例如：k -&gt; new Integer(4)），并把表达式执行结果保存到map中。涉及到key来计算value时才有使用价值，否则可以用putIfAbsent代替 5 default V computeIfPresent(K key,BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) 如果key存在，执行lambda表达式（例如：(k,oldval) -&gt; 2），并把表达式执行结果保存到map中；如果key不存在，不会put也不会报空指针异常。 6 public V replace(K key, V value) 如果key存在，就替换为新值并返回旧值；如果key不存在，返回null。 7 public boolean replace(K key, V oldValue, V newValue) 如果key-oldValue存在，就替换为newValue并返回true；否则，返回false。 HashMap类中详细的API列表如下： 关于HashMap一些常用的以及新增的方法，进行了详细的说明，有些方法通过方法名就能猜出其作用，只有知道了这些方法怎么用，能够解决哪些问题，然后多用多想，才能熟练掌握这些方法！","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://zhifeiyuntian.com/categories/Java基础/"}],"tags":[{"name":"Map","slug":"Map","permalink":"http://zhifeiyuntian.com/tags/Map/"}]},{"title":"生产者/消费者模式的理解及实现","slug":"producersandconsumers","date":"2019-11-06T06:10:44.000Z","updated":"2019-11-11T07:29:07.328Z","comments":true,"path":"2019/11/06/producersandconsumers/","link":"","permalink":"http://zhifeiyuntian.com/2019/11/06/producersandconsumers/","excerpt":"前言生产者消费者模式并不是GOF提出的23种设计模式之一，23种设计模式都是建立在面向对象的基础上的，但其实面向过程的编程中也有很多高效的编程模式，生产者消费者模式便是其中之一，它是我们编程过程中最常用的一种设计模式。 在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类，函数，线程，进程等）。产生数据的模块，就形象的称为生产者；处理数据的模块，就称为消费者。单就是抽象出生产者和消费者，还够不上生产者/消费者模式。该模式还需要一个缓冲区处于生产者和消费者之间，作为中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。","text":"前言生产者消费者模式并不是GOF提出的23种设计模式之一，23种设计模式都是建立在面向对象的基础上的，但其实面向过程的编程中也有很多高效的编程模式，生产者消费者模式便是其中之一，它是我们编程过程中最常用的一种设计模式。 在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类，函数，线程，进程等）。产生数据的模块，就形象的称为生产者；处理数据的模块，就称为消费者。单就是抽象出生产者和消费者，还够不上生产者/消费者模式。该模式还需要一个缓冲区处于生产者和消费者之间，作为中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。 优点可能有同学会问了，这个缓冲区有什么用呢？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去？ 那么我们就来了解一下有哪些优点： 解耦 假设生产者和消费者分别是两个类，如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖，就是耦合。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。 支持并发 生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白浪费时间。 使用了生产者/消费者模式之后，生产者和消费者可以是两个独立的并发主体。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。 支持忙闲不均 缓冲区还有另外一个好处，如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中；等生产者的制造速度慢下来，消费者再慢慢处理。 数据单元以及特性所谓的数据单元，简单的说，每次生产者放到缓冲区，就是一个数据单元；消费者每次从缓冲区取出的，也是一个数据单元。 数据单元的特性如下： 关联到业务对象 数据单元必须关联到某种业务对象。在考虑该问题的时候，你必须深刻理解当前这个生产者消费者模式所对应的业务逻辑，才能够作出合适的判断。这一步很重要，如果选错业务对象，会导致后续程序设计和编码实现的复杂度大为上升，增加了开发和维护成本。 完整性 完整性就是在传输过程中，要保证该数据单元的完整。要么整个数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现部分传递的情形。 独立性 独立性就是各个数据单元之间没有互相依赖，某个数据单元传输失败不应该影响已经完成传输的单元；也不应该影响尚未传输的单元。 颗粒度 数据单元和业务对象的关系： 可能是一一对应，很多场合确实是这种关系。 还有可能是出于性能等因素的考虑，会把N个业务对象打包成一个数据单元。N如何取值值得考虑，颗粒度太大会造成某种浪费，太小会造成性能问题。需要基于多方面因素的权衡，以及经验考量。 代码实现生产者消费者问题是个非常典型的多线程问题，涉及到的对象：生产者，消费者，仓库和产品。 他们之间的关系如下： 生产者在仓库未满时生产，仓满停止生产并等待 消费者在仓库有产品时才能消费，仓空则等待 当消费者发现仓库没产品可消费时候会通知生产者生产 当生产者在生产出可消费产品的时候，应该通知等待的消费者去消费 方法一：使用wait/notify/notifyAll实现生产者类：Producer 123456789101112131415161718192021222324252627282930313233package com.bsk.producerandconsumer;import java.util.ArrayList;public class Producer &#123; public Object object; public ArrayList&lt;Integer&gt; list; public Producer(Object object, ArrayList&lt;Integer&gt; list) &#123; super(); this.object = object; this.list = list; &#125; public void produce() &#123; synchronized (object) &#123; try &#123; // 只用缓冲区为空时，生产者才会进行生产操作 while (!list.isEmpty()) &#123; System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;); object.wait(); &#125; int value = 100; list.add(value); System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;); object.notifyAll(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类：Consumer 1234567891011121314151617181920212223242526272829package com.bsk.producerandconsumer;import java.util.ArrayList;public class Consumer &#123; public Object object; public ArrayList&lt;Integer&gt; list; public Consumer(Object object, ArrayList&lt;Integer&gt; list) &#123; super(); this.object = object; this.list = list; &#125; public void consumer() &#123; synchronized (object) &#123; try &#123; // 只用list不为空时才会进行消费操作 while (list.isEmpty()) &#123; System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;); object.wait(); &#125; list.clear(); System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;); object.notifyAll(); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125; 生产者线程类： 12345678910111213141516package com.bsk.producerandconsumer;public class ProducerThread extends Thread&#123; private Producer p; public ProducerThread(Producer p) &#123; this.p = p; &#125; @Override public void run() &#123; while (true) &#123; p.produce(); &#125; &#125;&#125; 消费者线程类： 1234567891011121314151617package com.bsk.producerandconsumer;public class ConsumerThread extends Thread&#123; private Consumer consumer; public ConsumerThread(Consumer consumer) &#123; super(); this.consumer = consumer; &#125; @Override public void run() &#123; while (true) &#123; consumer.consumer(); &#125; &#125;&#125; 客户端类： 123456789101112131415161718package com.bsk.producerandconsumer;import java.util.ArrayList;public class Main &#123; public static void main(String[] args) &#123; Object object = new Object(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Producer producer = new Producer(object, list); Consumer consumer = new Consumer(object, list); for (int i = 0; i &lt; 2; i++) &#123; ProducerThread producerThread = new ProducerThread(producer); ConsumerThread consumerThread = new ConsumerThread(consumer); producerThread.start(); consumerThread.start(); &#125; &#125;&#125; 方法二：用Lock和Condition实现服务类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.bsk.producerandconsumer2;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class MyService &#123; private ReentrantLock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean hasValue = false; public void produce() &#123; lock.lock(); try &#123; while (hasValue) &#123; System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;); condition.await(); &#125; hasValue = true; System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;); condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consumer() &#123; lock.lock(); try &#123; while (hasValue) &#123; System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;); condition.await(); hasValue = false; System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;); condition.signalAll(); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 生产者线程类： 123456789101112131415161718package com.bsk.producerandconsumer2;public class ProducerThread extends Thread&#123; private MyService service; public ProducerThread(MyService service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; while (true) &#123; service.produce(); &#125; &#125;&#125; 消费者线程类： 1234567891011121314151617package com.bsk.producerandconsumer2;public class ConsumerThread extends Thread&#123; private MyService service; public ConsumerThread(MyService service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; while (true) &#123; service.consumer(); &#125; &#125;&#125; 客户端类： 12345678910111213package com.bsk.producerandconsumer2;public class Main &#123; public static void main(String[] args) &#123; MyService service = new MyService(); for (int i = 0; i &lt; 2; i++) &#123; ProducerThread producerThread = new ProducerThread(service); ConsumerThread consumerThread = new ConsumerThread(service); producerThread.start(); consumerThread.start(); &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhifeiyuntian.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://zhifeiyuntian.com/tags/设计模式/"}]},{"title":"Linux常用命令","slug":"linux","date":"2019-10-12T01:39:11.000Z","updated":"2019-10-12T03:55:28.103Z","comments":true,"path":"2019/10/12/linux/","link":"","permalink":"http://zhifeiyuntian.com/2019/10/12/linux/","excerpt":"前言现在Java开发的大多数应用都是部署在Linux操作系统上的，因此掌握一些Linux常用命令就很有必要！那么我们就来学习一下，平时常用的Linux命令的基本使用。 学习Linux终端命令的技巧 不需要死记硬背，对于常用命令，用的多了，熟了，自然就记住了 不要尝试一次学会所有的命令，有些命令非常不常用，临时遇到，百度一下 常用命令","text":"前言现在Java开发的大多数应用都是部署在Linux操作系统上的，因此掌握一些Linux常用命令就很有必要！那么我们就来学习一下，平时常用的Linux命令的基本使用。 学习Linux终端命令的技巧 不需要死记硬背，对于常用命令，用的多了，熟了，自然就记住了 不要尝试一次学会所有的命令，有些命令非常不常用，临时遇到，百度一下 常用命令 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print work directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 08 cat [文件名] catch 获取文件内容并进行全部展示 09 more [文件名] more 获取文件内容并进行部分展示 10 mv move 移动文件位置/文件重命名 11 find find 文件搜索命令 12 tar tape archive 文件的压缩解压缩命令 13 zip/unzip zip/unzip 压缩/解压缩文件命令 14 ping ping 测试与目标网络是否连接成功的命令 15 ifconfig ifconfig 查看本地网卡信息 16 shutdown shutdown 系统关机命令 17 reboot reboot 系统重启命令 18 grep grep 将指定内容进行过滤然后输出命令 19 chmod [文件/目录] change mode 修改文件目录的权限 20 sudo [命令] switch user do 切换root用户执行命令 21 cp copy 复制文件 22 vim Vi IMproved 编辑文件 小技巧 ctrl + shift + =放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 注意：一些命令是可以后跟选项的，例如 ls -l 其中选项-l，表示以列表的形式展示结果 mkdir -p 目录名 其中选项-p ,表示可以递归创建目录 rm -r 目录名 其中选项-r,表示可以递归删除目录 帮助命令 序号 命令 对应英文 作用 01 which [命令] which 查看命令所在的目录位置 02 man [命令] Manual 获取命令的帮助文档，查看命令使用规则 03 命令 –help help 获取命令的帮助文档，查看命令使用规则 自动补全敲出文件/目录/命令的前几个字母之后，按下tab键，如果输入的没有歧义，系统会自动补全 总结学习是一个循序渐进的过程，平时工作中要多注意积累和总结，希望我们在开发的道路上走的更好，更远……","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhifeiyuntian.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhifeiyuntian.com/tags/Linux/"}]},{"title":"Java基础 （二）List","slug":"arraylist","date":"2019-03-08T03:40:12.000Z","updated":"2019-10-12T03:48:01.853Z","comments":true,"path":"2019/03/08/arraylist/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/08/arraylist/","excerpt":"前言今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。 ArrayList介绍ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable","text":"前言今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。 ArrayList介绍ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从上边源码可以看到，ArrayList继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口 * 继承AbstractList，实现List：提供了相关的添加、删除、修改、遍历等 * 实现RandomAccess接口：提供了快速随机访问功能，即可以通过元素下标快速获取元素对象 * 实现Cloneable接口：重写函数clone()，提供被克隆功能 * 实现java.io.Serializable：使ArrayList支持序列化的功能，能够通过序列化去传输。 ArrayList中的操作非线程安全的，建议在单线程中使用，在多线程中可以使用CopyOnWriteArrayList。 ArrayList源码分析成员变量12transient Object[] elementData; // non-private to simplify nested class accessprivate int size; 这两句源码，可以看出：ArrayList包含了两个重要的对象elementData和size。 * Object[] elementData，它保存添加到ArrayList中的元素。是个动态数组。 * size是ArrayList中元素的实际个数 构造函数12345678910111213141516171819202122232425262728293031323334// 默认容量大小private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 给定初始容量大小的构造函数public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125;// 初始容量为10的默认构造函数public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125;// 创建一个包含Collection的ArrayListpublic ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; add方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 方式1public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;其中的类内部方法ensureCapacityInternal：private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;// 方式2public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;// 方式3public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;// 方式4public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 方式1：在列表末尾插入值 * 首先进行扩容的校验 * 将值插入下标为size的位置，然后size++（就是实际大小加一） 方式2：在指定位置插入值 * 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常 * 接着进行扩容校验 * 将值插入到下标为index的位置，然后size++ 方式3：在列表末尾插入Collection * Collection调用toArray(),转化为Object[] 数组 * 获取数组长度numNew * 根据size + numNew的值进行扩容校验 * 将Collection转化的数组拼接到elementData的末尾 * size += numNew 方式4：在指定位置插入Collection * 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常 * Collection调用toArray(),转化为Object[] 数组a * 获取数组长度numNew * 根据size + numNew的值进行扩容校验 * 判断numMoved &gt; 0（numMoved = size - index）， 为真：拷贝原数组中index后所有元素，到新数组中的index+numNew以及后面的位置 * 拷贝数组a所有元素按之前排列顺序到数组elementData中的[index,index+numNew-1]位置 * size += numNew remove方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102方式1：按索引删除元素public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;方式2：根据值删除列表中某个元素public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125;方式3：将列表中元素全部清除public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125;方式4：删除两个列表中的交集部分public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125;方式5：按照一定规则过虑集合中的元素public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; set方法1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; get方法12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 其他方法 序号 方法 说明 1 public Object clone() 将一个list拷贝一份到新的list中 2 public boolean contains(Object o) 判断list中是否包含某个对象实例 3 public void forEach(Consumer&lt;? super E&gt; action) JDK1.8新增的forEach遍历元素方法参考 4 public int indexOf(Object o) 获取某个实例对象第一次出现的位置下标 5 public boolean isEmpty() 判断是否为空 6 public Iterator iterator() 获取Iterator迭代器 7 public int lastIndexOf(Object o) 获取某个实例对象最后一次出现的位置下标 8 public ListIterator listIterator() 获取ListIterator迭代器 9 public ListIterator listIterator(int index) 获取指针指向index的ListIterator迭代器 10 public void replaceAll(UnaryOperator operator) 11 public boolean retainAll(Collection&lt;?&gt; c) 获取两个集合中交集 12 public int size() 获取list的元素个数 13 public void sort(Comparator&lt;? super E&gt; c) 按比较器c的方式进行排序 14 public Spliterator spliterator() 主要用来多线程并行迭代的迭代器Spliterator，JDK1.8新增方法参考 15 public List subList(int fromIndex, int toIndex) 截取子List 16 public Object[] toArray() 将List转化为Object[]数组，如果将Object[]数组转换成其他类型，会抛出ClassCastException异常，因为Java不支持乡下转型。 17 public T[] toArray(T[] a) 传入一个数组作为参数，并通过泛型T的方式定义参数，所返回的数组类型就是调用集合的泛型，所以自己无需在转型；根据传入数组的长度，与集合的实际长度的关系：a，数组长度不小于集合长度，直接拷贝，不会产生新的数组对象；b，数组长度小于集合长度，会创建一个与集合长度相同的新数组，将集合的数据拷贝到新数组并将新数组的引用返回 ArrayList遍历方式方式1：通过迭代器遍历1234Iterator&lt;Integer&gt; iterator = list.iterator();while (iterator.hasNext()) &#123; iterator.next();&#125; 方式2：通过索引值遍历，随机访问123for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i);&#125; 方式3：通过forEach1234Integer value = null;for (Integer integer : list) &#123; value = integer;&#125; 方式4：通过forEach方法123456list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; ; &#125;&#125;); 通过一个实例，来测试一下这几种方式的遍历速率：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TestArrayListAccess &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 1000000; i++) &#123; list1.add(i); &#125; // 方式1 iteratorTest(list1); // 方式2 randomAccessTest(list1); // 方式3 forEachTest(list1); // 方式4 forEachTest1(list1); &#125; // iterator方式 public static void iteratorTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;Iterator耗时：&quot; + interval +&quot;ms&quot;); &#125; // 随机访问方式 public static void randomAccessTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i = 0; i &lt; list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;随机访问耗时：&quot;+ interval + &quot;ms&quot;); &#125; // forEach方式 public static void forEachTest(List&lt;Integer&gt; list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (@SuppressWarnings(&quot;unused&quot;) Integer integer : list) &#123; ; &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(&quot;forEach访问耗时：&quot;+ interval + &quot;ms&quot;); &#125; // 调用List的forEach方法 public static void forEachTest1(List&lt;Integer&gt; list) &#123; long startTime = System.currentTimeMillis(); list.forEach(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer t) &#123; ; &#125; &#125;); long endTime = System.currentTimeMillis(); System.out.println(&quot;forEach 方法耗时：&quot; + (endTime-startTime) + &quot;ms&quot;); &#125; &#125; 运行结果： Iterator耗时：5ms随机访问耗时：4msforEach访问耗时：7msforEach 方法耗时：7ms 从上边结果可以看出，遍历ArrayList时，使用索引遍历访问的时候效率最高，而使用其他方式时，效率偏低。 总结本文介绍了ArrayList，其中包括其构造函数和方法以及它们的源码解析，最后介绍了ArrayList的遍历方式，并且通过一个实例，比较了这几种遍历方式的效率。 寄语希望这篇文章能够给大家带来一点帮助！我的口号是：我分享，我快乐，越分享，越快乐！感谢各位老铁的支持。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://zhifeiyuntian.com/categories/Java基础/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://zhifeiyuntian.com/tags/集合/"}]},{"title":"Java基础 （一）字符串","slug":"string","date":"2019-03-05T23:54:54.000Z","updated":"2019-03-18T05:39:00.584Z","comments":true,"path":"2019/03/06/string/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/06/string/","excerpt":"前言字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。","text":"前言字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。 1、String构造函数 序号 构造函数 说明 1 public String() 构造空字符String对象 2 public String(String original) 构造一个新的相同的String对象 3 public String(char value[]) 通过给定字符数组，构造String对象 4 public String(char value[], int offset, int count) 给定字符数组，通过下标偏移量（offset），截取量（count）截取子数组，构建包含此子数组的String对象 5 String(int[] codePoints, int offset, int count) 给定int数组，通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 6 public String(byte bytes[]) 使用平台默认的字符集解码指定的byte数组，构造String 对象 7 public String(byte bytes[], int offset, int length) 通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 8 public String(byte bytes[], String charsetName) 通过字符集名字（charsetName）确定字符集，然后利用此字符集解码指定的byte数组，构建String对象 9 public String(byte bytes[], int offset, int length, String charsetName) 通过下标偏移位置（offset），截取量（count）截取子数组，通过字符集名字确定字符集，利用此字符集解码指定的byte子数组，构建String对象 10 public String(byte bytes[], Charset charset) 利用字符集charset解码指定的byte数组，构建String对象；jdk1.6新增 11 public String(byte bytes[], int offset, int length, Charset charset) 通过下标偏移位置（offset），截取量（count）截取子数组，然后利用字符集charset解码指定的byte子数组，构建String对象；jdk1.6新增 12 public String(StringBuffer buffer) 通过给定的StringBuffer，构建String对象 13 public String(StringBuilder builder) 通过给定的StringBuffer，构建String对象 2、常见的String方法函数 序号 方法函数 说明 1 public int length() 获取字符串长度 2 public boolean isEmpty() 判断字符串是否为空 3 public char charAt(int index)) 获取下标index下的字符 4 public byte[] getBytes() 将字符串转换成字节数组 5 public byte[] getBytes(String charsetName) 通过指定字符集名字将字符串转换成字节数组 6 public byte[] getBytes(Charset charset)) 通过指定字符集将字符串转换成字节数组 7 public boolean equals(Object anObject) 判断两个对象中字符是否都相同 8 public boolean contentEquals(StringBuffer sb)) 判断字符串对象和StringBuffer中内容是否相同 9 public boolean equalsIgnoreCase(String anotherString) 判断与另一个给定的字符串对象忽略大小写后的内容是否相同 10 public int compareTo(String anotherString) 与另一个字符串对象比较大小 11 public int indexOf(String str) 查找指定子串在字符串中第一次出现的位置下标 12 public int indexOf(String str, int fromIndex) 指定从起始下标位置开始查找指定子串在字符串中第一次出现的位置下标 13 public String substring(int beginIndex) 截取从起始下标位置开始到字符串末尾的子串 14 public String substring(int beginIndex, int endIndex) 截取从起始下标位置开始到（结束下标位置-1）的子串 15 public String concat(String str) 两个字符串拼接 16 public String replace(char oldChar, char newChar) 用newChar替换字符串中出现的oldChar 17 public boolean matches(String regex) 正则表达式匹配，匹配成功返回true，匹配失败返回false 18 public String[] split(String regex) 字符串在regex出现的地方进行分割，转换成字符串数组 19 public String[] split(String regex, int limit) 字符串在regex出现的地方进行分割，limit为分割的次数，分割成字符串数组，长度=limit+1 20 public String toLowerCase() 字符串中大写字母全部变成小写字母 21 public String toUpperCase() 字符串中小写字母全部变成大写字母 22 public String trim() 去除字符串首尾两端的空白字符 23 public char[] toCharArray() 字符串转化成字符数组 24 public static String valueOf(Object obj) 其他对象转化成字符串，静态方法，使用方式：String.valueOf(obj) 25 public static String join(CharSequence delimiter, CharSequence… elements) 字符串拼接，jdk1.8新增 3、== 和 equals 两者之间的区别3.1、==比较对于基本类型和引用类型==的作用效果是不同的： * 基本类型：比较的是值是否相同 * 引用类型：比较的是引用是否相同 3.2、equals比较equals本质上就是==，只不过String类重写了equals方法，源码如下：123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 从源码中可以看出，当是引用比较的时候改成了值比较。 示例代码：1234567String s1 = &quot;hello&quot;;String s2 = &quot;hello&quot;;String s3 = new String(&quot;hello&quot;);System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // falseSystem.out.println(s1.equals(s2)); // trueSystem.out.println(s1.equals(s3)); // true 字符串对象的创建过程：String类在内存中管理着一个字符串常量池，池中所有相同的字符串常量只占用同一个内存空间。 * String s1 = &quot;hello&quot;;执行这句代码时，程序会先看常量池中是否有“hello”这个字符串常量，如果没有就创建一个“hello”字符串对象，并且让引用s1指向这个对象；如果有，让引用s1直接指向常量池中已经存在的hello对象。 * String s3 = new String(&quot;hello&quot;);而执行这句代码时，重复s1的操作，然后执行new String() ,重新在堆中开辟了一个内存空间，将常量池中的hello对象复制一份到这个内存空间中，让引用s3指向堆中这个刚创建的hello对象。 4、StringBuffer和StringBuilder的区别4.1、相同点* 可增长，可改写 * 提供了字符串的许多其他功能 4.2、不同点* StringBuffer是线程同步的，意味着它是线程安全的，但是牺牲了对字符串操作的性能 * StringBuilder不是同步的，意味着它是线程不安全的，但是具有更快的字符串操作性能 5、StringJoiner类Java开发中，有时候会遇到字符串拼接的操作，你可能会直接想到就是使用 + 这个操作符直接进行拼接，或者使用StringBuilder或者StringBuffer来实现，那么还有一种重要的拼接方式，就是Java8中提供的StringJoiner，还不了解这种拼接方式的童鞋，那我们就来共同学习一下这个字符串拼接类！ 5.1、StringJoiner类的构造函数12345678910111213141516public StringJoiner(CharSequence delimiter) &#123; this(delimiter, &quot;&quot;, &quot;&quot;);&#125;public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // make defensive copies of arguments this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;&#125; StringJoiner类共有上面2个构造函数，从上面可以看出，第一个构造函数就是调用第二个构造函数，那么我们就来分析一下第二个构造函数，其中delimiter这个参数表示字符串进行拼接的时候以delimiter作为分隔符，prefix代表字符串拼接后的前缀，suffix代表字符串拼接后的后缀。 StringJoiner的用法比较简单 示例代码： 12345678public class TestJoiner &#123; public static void main(String[] args) &#123; StringJoiner sJoiner = new StringJoiner(&quot;,&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;); sJoiner.add(&quot;hello&quot;); sJoiner.add(&quot;world&quot;); System.out.println(sJoiner.toString()); &#125;&#125; 以上代码输出结果： 1&#123;hello,world&#125; 5.2、常用的add方法123456789101112public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this;&#125;private StringBuilder prepareBuilder() &#123; if (value != null) &#123; value.append(delimiter); &#125; else &#123; value = new StringBuilder().append(prefix); &#125; return value;&#125; StringJoiner其实就是依赖StringBuilder实现的 看到这，有些童鞋可能会产生一个疑问，不是已经有StringBuilder了，为什么Java8中还要定义一个StringJoiner呢？ 现在有一个需求：如果我们有这样一个List，这个List中呢，有“hello”，“world”， 想要把它拼接成一个以下形式的字符串： 1hello:world 方式一：使用StringBuilder实现 12345678StringBuilder builder = new StringBuilder();if(!list.isEmpty()) &#123; builder.append(list.get(0)); for (int i = 1; i &lt; list.size(); i++) &#123; builder.append(&quot;:&quot;).append(list.get(i)); &#125;&#125;System.out.println(builder.toString()); 方式二：使用stream()实现 1list.stream().reduce(new StringBuilder(),(sb, s)-&gt;sb.append(s).append(&quot;:&quot;),StringBuilder::append).toString(); 输出结果： 1hello:world: 这种方式需要进行二次处理 方式三：使用操作符+实现 12345678String sum_string = &quot;&quot;;if(!list.isEmpty()) &#123; sum_string += list.get(0); for (int i = 1; i &lt; list.size(); i++) &#123; sum_string +=&quot;:&quot;+list.get(i); &#125;&#125;System.out.println(sum_string); 以上几种方式，要么是代码复杂，要么是性能不高。 如果使用StringJoiner，一行代码就可以搞定： 1list.stream().collect(Collectors.joining(&quot;:&quot;)); 其中，Collectors.joining()的源代码： 1234567891011public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123; return joining(delimiter, &quot;&quot;, &quot;&quot;); &#125;public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; return new CollectorImpl&lt;&gt;( () -&gt; new StringJoiner(delimiter, prefix, suffix), StringJoiner::add, StringJoiner::merge, StringJoiner::toString, CH_NOID); &#125; joining方法的实现原理就是借助了StringJoiner。 如果改变需求，在拼接后的字符串添加前缀“{”，和后缀“}”，那么StringJoiner的优势就会很明显了。 需要注意的一点是： StringJoiner是通过StringBuilder实现的，也就是说它也是非线程安全的。 日常开发中，需要进行字符串拼接，如何选择？ * 如果是简单字符串拼接，直接使用+即可 * 如果是在for循环中进行字符串拼接，考虑使用StringBuilder或者StringBuffer。 * 如果是通过一个集合，例如list，进行拼接考虑使用StringJoiner 总结字符串在Java开发中应用非常广泛，熟练掌握能避免一些不必要的坑！ 寄语希望这篇文章能给大家带来一点帮助，如果文章中有哪些错误之处，还请批评指正！我的口号是：我分享，我快乐，越分享，越快乐！感谢各位老铁的支持。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://zhifeiyuntian.com/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhifeiyuntian.com/tags/Java/"},{"name":"String","slug":"String","permalink":"http://zhifeiyuntian.com/tags/String/"}]},{"title":"第一次总结","slug":"interview","date":"2019-03-05T07:32:33.000Z","updated":"2019-03-18T05:34:03.081Z","comments":true,"path":"2019/03/05/interview/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/05/interview/","excerpt":"前言 创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。","text":"前言 创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。 进步 学习了一些新技能： * 熟悉了Markdown语法 * 利用阿里云解析了GitHub和coding里的Pages服务 * HEXO和主题配置 主题配置 站点配置文件_config.yml：123456789101112131415161718192021222324252627282930313233343536373839# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/# 搜索search: path: search.xml field: post format: html limit: 10000#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #type: git type: git repo: github: git@github.com:MrWhiteSike/MrWhiteSike.github.io.git,master coding: git@git.coding.net:MrWhiteSike/MrWhiteSike.git,master 主题配置文件/themes/next/_config.yml:参考了这篇博文，具体配置细节还请自己琢磨 结束 做这个博客呢，愿景有二： * 记录生活中的点滴故事 * 分享知识，提升技能","categories":[{"name":"总结","slug":"总结","permalink":"http://zhifeiyuntian.com/categories/总结/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://zhifeiyuntian.com/tags/生活/"}]},{"title":"开篇博客","slug":"firstpaper","date":"2019-03-01T00:26:29.000Z","updated":"2019-03-18T08:00:36.575Z","comments":true,"path":"2019/03/01/firstpaper/","link":"","permalink":"http://zhifeiyuntian.com/2019/03/01/firstpaper/","excerpt":"开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！","text":"开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！ 大概花了几天时间利用HEXO框架搭建了这个博客，建好之后心情还有点小激动，毕竟经过自己的一番努力，终于实现拥有专属于自己的个人博客网站，这里参考了hexo史上最全搭建教程，感谢这篇文章的博主，写的如此清晰，才让我如此快速的搭建起个人博客网站。 俗话说：万事开头难。但是只要相信，勇于实践，锲而不舍，方能成功。只要开始，我们不可半途而废，越过山丘，我们才能看到山后的另一番景象！ 先写这么多吧，来日方长！","categories":[{"name":"生活","slug":"生活","permalink":"http://zhifeiyuntian.com/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://zhifeiyuntian.com/tags/随笔/"}]}]}