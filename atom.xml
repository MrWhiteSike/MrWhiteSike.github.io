<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr WhiteSike&#39;s Blog</title>
  
  <subtitle>不鸣则已，一飞冲天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhifeiyuntian.com/"/>
  <updated>2019-11-06T08:59:52.883Z</updated>
  <id>http://zhifeiyuntian.com/</id>
  
  <author>
    <name>Mr WhiteSike</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生产者/消费者模式的理解及实现</title>
    <link href="http://zhifeiyuntian.com/2019/11/06/producersandconsumers/"/>
    <id>http://zhifeiyuntian.com/2019/11/06/producersandconsumers/</id>
    <published>2019-11-06T06:10:44.000Z</published>
    <updated>2019-11-06T08:59:52.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/7492e49ae3f116014272e0acb6190c4b.jpg?raw=true" alt></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>生产者消费者模式并不是GOF提出的23种设计模式之一，23种设计模式都是建立在面向对象的基础上的，但其实面向过程的编程中也有很多高效的编程模式，生产者消费者模式便是其中之一，它是我们编程过程中最常用的一种设计模式。</p><p>在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类，函数，线程，进程等）。产生数据的模块，就形象的称为生产者；处理数据的模块，就称为消费者。单就是抽象出生产者和消费者，还够不上生产者/消费者模式。该模式还需要一个缓冲区处于生产者和消费者之间，作为中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>可能有同学会问了，这个缓冲区有什么用呢？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去？</p><p>那么我们就来了解一下有哪些优点：</p><ul><li><p><strong>解耦</strong></p><p>假设生产者和消费者分别是两个类，如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖，就是耦合。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。</p></li><li><p><strong>支持并发</strong></p><p>生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白浪费时间。</p><p>使用了生产者/消费者模式之后，生产者和消费者可以是两个独立的并发主体。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。</p></li><li><p><strong>支持忙闲不均</strong></p><p>缓冲区还有另外一个好处，如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中；等生产者的制造速度慢下来，消费者再慢慢处理。</p></li></ul><h1 id="数据单元以及特性"><a href="#数据单元以及特性" class="headerlink" title="数据单元以及特性"></a>数据单元以及特性</h1><p>所谓的数据单元，简单的说，每次生产者放到缓冲区，就是一个数据单元；消费者每次从缓冲区取出的，也是一个数据单元。</p><p>数据单元的特性如下：</p><ul><li><p><strong>关联到业务对象</strong></p><p>数据单元必须关联到某种业务对象。在考虑该问题的时候，你必须深刻理解当前这个生产者消费者模式所对应的业务逻辑，才能够作出合适的判断。这一步很重要，如果选错业务对象，会导致后续程序设计和编码实现的复杂度大为上升，增加了开发和维护成本。</p></li><li><p><strong>完整性</strong></p><p>完整性就是在传输过程中，要保证该数据单元的完整。要么整个数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现部分传递的情形。</p></li><li><p><strong>独立性</strong></p><p>独立性就是各个数据单元之间没有互相依赖，某个数据单元传输失败不应该影响已经完成传输的单元；也不应该影响尚未传输的单元。</p></li><li><p><strong>颗粒度</strong></p><p>数据单元和业务对象的关系：</p><p>可能是一一对应，很多场合确实是这种关系。</p><p>还有可能是出于性能等因素的考虑，会把N个业务对象打包成一个数据单元。N如何取值值得考虑，颗粒度太大会造成某种浪费，太小会造成性能问题。需要基于多方面因素的权衡，以及经验考量。</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>生产者消费者问题是个非常典型的多线程问题，涉及到的对象：生产者，消费者，仓库和产品。</p><p>他们之间的关系如下：</p><ol><li>生产者在仓库未满时生产，仓满停止生产并等待</li><li>消费者在仓库有产品时才能消费，仓空则等待</li><li>当消费者发现仓库没产品可消费时候会通知生产者生产</li><li>当生产者在生产出可消费产品的时候，应该通知等待的消费者去消费</li></ol><h2 id="方法一：使用wait-notify-notifyAll实现"><a href="#方法一：使用wait-notify-notifyAll实现" class="headerlink" title="方法一：使用wait/notify/notifyAll实现"></a>方法一：使用wait/notify/notifyAll实现</h2><p>生产者类：Producer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line">public Object object;</span><br><span class="line">public ArrayList&lt;Integer&gt; list;</span><br><span class="line">public Producer(Object object, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">super();</span><br><span class="line">this.object = object;</span><br><span class="line">this.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void produce() &#123;</span><br><span class="line">synchronized (object) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 只用缓冲区为空时，生产者才会进行生产操作</span><br><span class="line">while (!list.isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;);</span><br><span class="line">object.wait();</span><br><span class="line">&#125;</span><br><span class="line">int value = 100;</span><br><span class="line">list.add(value);</span><br><span class="line">System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;);</span><br><span class="line">object.notifyAll();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者类：Consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line">public Object object;</span><br><span class="line">public ArrayList&lt;Integer&gt; list;</span><br><span class="line">public Consumer(Object object, ArrayList&lt;Integer&gt; list) &#123;</span><br><span class="line">super();</span><br><span class="line">this.object = object;</span><br><span class="line">this.list = list;</span><br><span class="line">&#125;</span><br><span class="line">public void consumer() &#123;</span><br><span class="line">synchronized (object) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 只用list不为空时才会进行消费操作</span><br><span class="line">while (list.isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;);</span><br><span class="line">object.wait();</span><br><span class="line">&#125;</span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;);</span><br><span class="line">object.notifyAll();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO: handle exception</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者线程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer;</span><br><span class="line"></span><br><span class="line">public class ProducerThread extends Thread&#123;</span><br><span class="line">private Producer p;</span><br><span class="line"></span><br><span class="line">public ProducerThread(Producer p) &#123;</span><br><span class="line">this.p = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">p.produce();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者线程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer;</span><br><span class="line"></span><br><span class="line">public class ConsumerThread extends Thread&#123;</span><br><span class="line">private Consumer consumer;</span><br><span class="line"></span><br><span class="line">public ConsumerThread(Consumer consumer) &#123;</span><br><span class="line">super();</span><br><span class="line">this.consumer = consumer;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">consumer.consumer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Object object = new Object();</span><br><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">Producer producer = new Producer(object, list);</span><br><span class="line">Consumer consumer = new Consumer(object, list);</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">ProducerThread producerThread = new ProducerThread(producer);</span><br><span class="line">ConsumerThread consumerThread = new ConsumerThread(consumer);</span><br><span class="line">producerThread.start();</span><br><span class="line">consumerThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：用Lock和Condition实现"><a href="#方法二：用Lock和Condition实现" class="headerlink" title="方法二：用Lock和Condition实现"></a>方法二：用Lock和Condition实现</h2><p>服务类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer2;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class MyService &#123;</span><br><span class="line">private ReentrantLock lock = new ReentrantLock();</span><br><span class="line">private Condition condition  = lock.newCondition();</span><br><span class="line">private boolean hasValue = false;</span><br><span class="line"></span><br><span class="line">public void produce() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">while (hasValue) &#123;</span><br><span class="line">System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;);</span><br><span class="line">condition.await();</span><br><span class="line">&#125;</span><br><span class="line">hasValue = true;</span><br><span class="line">System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;);</span><br><span class="line">condition.signalAll();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void consumer() &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">while (hasValue) &#123;</span><br><span class="line">System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;等待……&quot;);</span><br><span class="line">condition.await();</span><br><span class="line">hasValue = false;</span><br><span class="line">System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;运行……&quot;);</span><br><span class="line">condition.signalAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者线程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer2;</span><br><span class="line"></span><br><span class="line">public class ProducerThread extends Thread&#123;</span><br><span class="line">private MyService service;</span><br><span class="line">public ProducerThread(MyService service) &#123;</span><br><span class="line">super();</span><br><span class="line">this.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">service.produce();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者线程类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer2;</span><br><span class="line"></span><br><span class="line">public class ConsumerThread extends Thread&#123;</span><br><span class="line">private MyService service;</span><br><span class="line">public ConsumerThread(MyService service) &#123;</span><br><span class="line">super();</span><br><span class="line">this.service = service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">service.consumer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.bsk.producerandconsumer2;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyService service = new MyService();</span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">ProducerThread producerThread = new ProducerThread(service);</span><br><span class="line">ConsumerThread consumerThread = new ConsumerThread(service);</span><br><span class="line">producerThread.start();</span><br><span class="line">consumerThread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/7492e49ae3f116014272e0acb6190c4b.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://zhifeiyuntian.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://zhifeiyuntian.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://zhifeiyuntian.com/2019/10/12/linux/"/>
    <id>http://zhifeiyuntian.com/2019/10/12/linux/</id>
    <published>2019-10-12T01:39:11.000Z</published>
    <updated>2019-10-12T03:55:28.103Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/155b3820ce3fc627fdf08a9204f8246c.jpg?raw=true" alt></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在Java开发的大多数应用都是部署在Linux操作系统上的，因此掌握一些Linux常用命令就很有必要！那么我们就来学习一下，平时常用的Linux命令的基本使用。</p><blockquote><p>学习Linux终端命令的技巧</p><ul><li>不需要死记硬背，对于常用命令，用的多了，熟了，自然就记住了</li><li>不要尝试一次学会所有的命令，有些命令非常不常用，临时遇到，百度一下</li></ul></blockquote><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><a id="more"></a><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">命令</th><th style="text-align:center">对应英文</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">ls</td><td style="text-align:center">list</td><td style="text-align:center">查看当前文件夹下的内容</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">pwd</td><td style="text-align:center">print work directory</td><td style="text-align:center">查看当前所在文件夹</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">cd [目录名]</td><td style="text-align:center">change directory</td><td style="text-align:center">切换文件夹</td></tr><tr><td style="text-align:center">04</td><td style="text-align:center">touch [文件名]</td><td style="text-align:center">touch</td><td style="text-align:center">如果文件不存在，新建文件</td></tr><tr><td style="text-align:center">05</td><td style="text-align:center">mkdir [目录名]</td><td style="text-align:center">make directory</td><td style="text-align:center">创建目录</td></tr><tr><td style="text-align:center">06</td><td style="text-align:center">rm [文件名]</td><td style="text-align:center">remove</td><td style="text-align:center">删除指定的文件名</td></tr><tr><td style="text-align:center">07</td><td style="text-align:center">clear</td><td style="text-align:center">clear</td><td style="text-align:center">清屏</td></tr><tr><td style="text-align:center">08</td><td style="text-align:center">cat [文件名]</td><td style="text-align:center">catch</td><td style="text-align:center">获取文件内容并进行全部展示</td></tr><tr><td style="text-align:center">09</td><td style="text-align:center">more [文件名]</td><td style="text-align:center">more</td><td style="text-align:center">获取文件内容并进行部分展示</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">mv</td><td style="text-align:center">move</td><td style="text-align:center">移动文件位置/文件重命名</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">find</td><td style="text-align:center">find</td><td style="text-align:center">文件搜索命令</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">tar</td><td style="text-align:center">tape archive</td><td style="text-align:center">文件的压缩解压缩命令</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">zip/unzip</td><td style="text-align:center">zip/unzip</td><td style="text-align:center">压缩/解压缩文件命令</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">ping</td><td style="text-align:center">ping</td><td style="text-align:center">测试与目标网络是否连接成功的命令</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">ifconfig</td><td style="text-align:center">ifconfig</td><td style="text-align:center">查看本地网卡信息</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">shutdown</td><td style="text-align:center">shutdown</td><td style="text-align:center">系统关机命令</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">reboot</td><td style="text-align:center">reboot</td><td style="text-align:center">系统重启命令</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">grep</td><td style="text-align:center">grep</td><td style="text-align:center">将指定内容进行过滤然后输出命令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">chmod [文件/目录]</td><td style="text-align:center">change mode</td><td style="text-align:center">修改文件目录的权限</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">sudo [命令]</td><td style="text-align:center">switch user do</td><td style="text-align:center">切换root用户执行命令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cp</td><td style="text-align:center">copy</td><td style="text-align:center">复制文件</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">vim</td><td style="text-align:center">Vi IMproved</td><td style="text-align:center">编辑文件</td></tr></tbody></table><blockquote><p>小技巧</p><ul><li><code>ctrl + shift + =</code>放大终端窗口的字体显示</li><li><code>ctrl + -</code> 缩小终端窗口的字体显示</li></ul></blockquote><p><code>注意：一些命令是可以后跟选项的，例如</code></p><ul><li><code>ls -l  其中选项-l，表示以列表的形式展示结果</code></li><li><code>mkdir -p 目录名     其中选项-p ,表示可以递归创建目录</code></li><li><code>rm -r 目录名    其中选项-r,表示可以递归删除目录</code></li></ul><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">命令</th><th style="text-align:center">对应英文</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">01</td><td style="text-align:center">which [命令]</td><td style="text-align:center">which</td><td style="text-align:center">查看命令所在的目录位置</td></tr><tr><td style="text-align:center">02</td><td style="text-align:center">man [命令]</td><td style="text-align:center">Manual</td><td style="text-align:center">获取命令的帮助文档，查看命令使用规则</td></tr><tr><td style="text-align:center">03</td><td style="text-align:center">命令 –help</td><td style="text-align:center">help</td><td style="text-align:center">获取命令的帮助文档，查看命令使用规则</td></tr></tbody></table><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h1><p>敲出<code>文件/目录/命令</code>的前几个字母之后，按下<code>tab</code>键，如果输入的没有歧义，系统会自动补全</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习是一个循序渐进的过程，平时工作中要多注意积累和总结，希望我们在开发的道路上走的更好，更远……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/155b3820ce3fc627fdf08a9204f8246c.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在Java开发的大多数应用都是部署在Linux操作系统上的，因此掌握一些Linux常用命令就很有必要！那么我们就来学习一下，平时常用的Linux命令的基本使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学习Linux终端命令的技巧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要死记硬背，对于常用命令，用的多了，熟了，自然就记住了&lt;/li&gt;
&lt;li&gt;不要尝试一次学会所有的命令，有些命令非常不常用，临时遇到，百度一下&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://zhifeiyuntian.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://zhifeiyuntian.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 （二）List</title>
    <link href="http://zhifeiyuntian.com/2019/03/08/arraylist/"/>
    <id>http://zhifeiyuntian.com/2019/03/08/arraylist/</id>
    <published>2019-03-08T03:40:12.000Z</published>
    <updated>2019-10-12T03:48:01.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/u=1095865518,1303788967&amp;fm=26&amp;gp=0.jpg?raw=true" alt></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。</p><h1 id="ArrayList介绍"><a href="#ArrayList介绍" class="headerlink" title="ArrayList介绍"></a>ArrayList介绍</h1><p>ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>从上边源码可以看到，ArrayList继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口</p><pre><code>* 继承AbstractList，实现List：提供了相关的添加、删除、修改、遍历等* 实现RandomAccess接口：提供了快速随机访问功能，即可以通过元素下标快速获取元素对象* 实现Cloneable接口：重写函数clone()，提供被克隆功能* 实现java.io.Serializable：使ArrayList支持序列化的功能，能够通过序列化去传输。</code></pre><p>ArrayList中的操作非线程安全的，建议在单线程中使用，在多线程中可以使用CopyOnWriteArrayList。</p><h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><p>这两句源码，可以看出：<br>ArrayList包含了两个重要的对象elementData和size。</p><pre><code>* Object[] elementData，它保存添加到ArrayList中的元素。是个动态数组。* size是ArrayList中元素的实际个数</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 默认容量大小</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// 给定初始容量大小的构造函数</span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 初始容量为10的默认构造函数</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 创建一个包含Collection的ArrayList</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line">            // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// 方式1</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">其中的类内部方法ensureCapacityInternal：</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line"></span><br><span class="line">    private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // minCapacity is usually close to size, so this is a win:</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 方式2</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 方式3</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">Object[] a = c.toArray();</span><br><span class="line">int numNew = a.length;</span><br><span class="line">ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">size += numNew;</span><br><span class="line">return numNew != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式4</span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line">Object[] a = c.toArray();</span><br><span class="line">int numNew = a.length;</span><br><span class="line">ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line"></span><br><span class="line">int numMoved = size - index;</span><br><span class="line">if (numMoved &gt; 0)</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">     numMoved);</span><br><span class="line"></span><br><span class="line">System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">size += numNew;</span><br><span class="line">return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式1：在列表末尾插入值</p><pre><code>* 首先进行扩容的校验* 将值插入下标为size的位置，然后size++（就是实际大小加一）</code></pre><p>方式2：在指定位置插入值</p><pre><code>* 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常* 接着进行扩容校验* 将值插入到下标为index的位置，然后size++</code></pre><p>方式3：在列表末尾插入Collection</p><pre><code>* Collection调用toArray(),转化为Object[] 数组* 获取数组长度numNew* 根据size + numNew的值进行扩容校验* 将Collection转化的数组拼接到elementData的末尾* size += numNew</code></pre><p>方式4：在指定位置插入Collection</p><pre><code>* 首先判断要插入的下标位置index是否在[0-size]之间，若不在会抛出IndexOutOfBoundsException异常* Collection调用toArray(),转化为Object[] 数组a* 获取数组长度numNew* 根据size + numNew的值进行扩容校验* 判断numMoved &gt; 0（numMoved = size - index），    为真：拷贝原数组中index后所有元素，到新数组中的index+numNew以及后面的位置* 拷贝数组a所有元素按之前排列顺序到数组elementData中的[index,index+numNew-1]位置* size += numNew</code></pre><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">方式1：按索引删除元素</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">方式2：根据值删除列表中某个元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">方式3：将列表中元素全部清除</span><br><span class="line">public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        // clear to let GC do its work</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            elementData[i] = null;</span><br><span class="line"></span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">方式4：删除两个列表中的交集部分</span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        return batchRemove(c, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">方式5：按照一定规则过虑集合中的元素</span><br><span class="line">public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        // figure out which elements are to be removed</span><br><span class="line">        // any exception thrown from the filter predicate at this stage</span><br><span class="line">        // will leave the collection unmodified</span><br><span class="line">        int removeCount = 0;</span><br><span class="line">        final BitSet removeSet = new BitSet(size);</span><br><span class="line">        final int expectedModCount = modCount;</span><br><span class="line">        final int size = this.size;</span><br><span class="line">        for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            final E element = (E) elementData[i];</span><br><span class="line">            if (filter.test(element)) &#123;</span><br><span class="line">                removeSet.set(i);</span><br><span class="line">                removeCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // shift surviving elements left over the spaces left by removed elements</span><br><span class="line">        final boolean anyToRemove = removeCount &gt; 0;</span><br><span class="line">        if (anyToRemove) &#123;</span><br><span class="line">            final int newSize = size - removeCount;</span><br><span class="line">            for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">                i = removeSet.nextClearBit(i);</span><br><span class="line">                elementData[j] = elementData[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for (int k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">                elementData[k] = null;  // Let gc do its work</span><br><span class="line">            &#125;</span><br><span class="line">            this.size = newSize;</span><br><span class="line">            if (modCount != expectedModCount) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            modCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return anyToRemove;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><table><thead><tr><th>序号</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>public Object clone()</td><td>将一个list拷贝一份到新的list中</td></tr><tr><td>2</td><td>public boolean contains(Object o)</td><td>判断list中是否包含某个对象实例</td></tr><tr><td>3</td><td>public void forEach(Consumer&lt;? super E&gt; action)</td><td>JDK1.8新增的forEach遍历元素方法<a href="https://blog.csdn.net/zixiao217/article/details/70196751" target="_blank" rel="noopener">参考</a></td></tr><tr><td>4</td><td>public int indexOf(Object o)</td><td>获取某个实例对象第一次出现的位置下标</td></tr><tr><td>5</td><td>public boolean isEmpty()</td><td>判断是否为空</td></tr><tr><td>6</td><td>public Iterator<e> iterator()</e></td><td>获取Iterator迭代器</td></tr><tr><td>7</td><td>public int lastIndexOf(Object o)</td><td>获取某个实例对象最后一次出现的位置下标</td></tr><tr><td>8</td><td>public ListIterator<e> listIterator()</e></td><td>获取ListIterator迭代器</td></tr><tr><td>9</td><td>public ListIterator<e> listIterator(int index)</e></td><td>获取指针指向index的ListIterator迭代器</td></tr><tr><td>10</td><td>public void replaceAll(UnaryOperator<e> operator)</e></td><td></td></tr><tr><td>11</td><td>public boolean retainAll(Collection&lt;?&gt; c)</td><td>获取两个集合中交集</td></tr><tr><td>12</td><td>public int size()</td><td>获取list的元素个数</td></tr><tr><td>13</td><td>public void sort(Comparator&lt;? super E&gt; c)</td><td>按比较器c的方式进行排序</td></tr><tr><td>14</td><td>public Spliterator<e> spliterator()</e></td><td>主要用来多线程并行迭代的迭代器Spliterator，JDK1.8新增方法<a href="https://www.cnblogs.com/nevermorewang/p/9368431.html" target="_blank" rel="noopener">参考</a></td></tr><tr><td>15</td><td>public List<e> subList(int fromIndex, int toIndex)</e></td><td>截取子List</td></tr><tr><td>16</td><td>public Object[] toArray()</td><td>将List转化为Object[]数组，如果将Object[]数组转换成其他类型，会抛出ClassCastException异常，因为Java不支持乡下转型。</td></tr><tr><td>17</td><td>public <t> T[] toArray(T[] a)</t></td><td>传入一个数组作为参数，并通过泛型T的方式定义参数，所返回的数组类型就是调用集合的泛型，所以自己无需在转型；根据传入数组的长度，与集合的实际长度的关系：a，数组长度不小于集合长度，直接拷贝，不会产生新的数组对象；b，数组长度小于集合长度，会创建一个与集合长度相同的新数组，将集合的数据拷贝到新数组并将新数组的引用返回</td></tr></tbody></table><h1 id="ArrayList遍历方式"><a href="#ArrayList遍历方式" class="headerlink" title="ArrayList遍历方式"></a>ArrayList遍历方式</h1><p>方式1：通过迭代器遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方式2：通过索引值遍历，随机访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方式3：通过forEach<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer value = null;</span><br><span class="line">for (Integer integer : list) &#123;</span><br><span class="line">value = integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方式4：通过forEach方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(Integer t) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通过一个实例，来测试一下这几种方式的遍历速率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public class TestArrayListAccess &#123;</span><br><span class="line">  </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">list1.add(i);</span><br><span class="line">&#125;</span><br><span class="line">// 方式1</span><br><span class="line">iteratorTest(list1);</span><br><span class="line">// 方式2</span><br><span class="line">randomAccessTest(list1);</span><br><span class="line">// 方式3</span><br><span class="line">forEachTest(list1);</span><br><span class="line">// 方式4</span><br><span class="line">forEachTest1(list1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iterator方式</span><br><span class="line">public static void iteratorTest(List&lt;Integer&gt; list) &#123;</span><br><span class="line">long startTime;</span><br><span class="line">long endTime;</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">iterator.next();</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">long interval = endTime - startTime;</span><br><span class="line">System.out.println(&quot;Iterator耗时：&quot; + interval +&quot;ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 随机访问方式</span><br><span class="line">public static void randomAccessTest(List&lt;Integer&gt; list) &#123;</span><br><span class="line">long startTime;</span><br><span class="line">long endTime;</span><br><span class="line">startTime = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">long interval = endTime - startTime;</span><br><span class="line">System.out.println(&quot;随机访问耗时：&quot;+ interval + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// forEach方式</span><br><span class="line">public static void forEachTest(List&lt;Integer&gt; list) &#123;</span><br><span class="line">long startTime;</span><br><span class="line">long endTime;</span><br><span class="line">startTime  = System.currentTimeMillis();</span><br><span class="line">for (@SuppressWarnings(&quot;unused&quot;) Integer integer : list) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">endTime = System.currentTimeMillis();</span><br><span class="line">long interval = endTime - startTime;</span><br><span class="line">System.out.println(&quot;forEach访问耗时：&quot;+ interval + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用List的forEach方法</span><br><span class="line">public static void forEachTest1(List&lt;Integer&gt; list) &#123;</span><br><span class="line">long startTime = System.currentTimeMillis();</span><br><span class="line">list.forEach(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void accept(Integer t) &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">long endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;forEach 方法耗时：&quot; + (endTime-startTime) + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><blockquote><p>Iterator耗时：5ms<br>随机访问耗时：4ms<br>forEach访问耗时：7ms<br>forEach 方法耗时：7ms</p></blockquote><p>从上边结果可以看出，遍历ArrayList时，使用索引遍历访问的时候效率最高，而使用其他方式时，效率偏低。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了ArrayList，其中包括其构造函数和方法以及它们的源码解析，最后介绍了ArrayList的遍历方式，并且通过一个实例，比较了这几种遍历方式的效率。</p><h1 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h1><p>希望这篇文章能够给大家带来一点帮助！<br>我的口号是：我分享，我快乐，越分享，越快乐！<br>感谢各位老铁的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/u=1095865518,1303788967&amp;amp;fm=26&amp;amp;gp=0.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天就来分析一下List中最常用的ArrayList，闲言少叙，直接进入正文。&lt;/p&gt;
&lt;h1 id=&quot;ArrayList介绍&quot;&gt;&lt;a href=&quot;#ArrayList介绍&quot; class=&quot;headerlink&quot; title=&quot;ArrayList介绍&quot;&gt;&lt;/a&gt;ArrayList介绍&lt;/h1&gt;&lt;p&gt;ArrayList是一个基于动态数组实现的列表，与Java数组相比，其容量可以动态增长。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhifeiyuntian.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://zhifeiyuntian.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 （一）字符串</title>
    <link href="http://zhifeiyuntian.com/2019/03/06/string/"/>
    <id>http://zhifeiyuntian.com/2019/03/06/string/</id>
    <published>2019-03-05T23:54:54.000Z</published>
    <updated>2019-03-18T05:39:00.584Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/u=1739492202,3928764710&amp;fm=26&amp;gp=0.jpg?raw=true" alt></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。</p><a id="more"></a><h1 id="1、String构造函数"><a href="#1、String构造函数" class="headerlink" title="1、String构造函数"></a>1、String构造函数</h1><table><thead><tr><th>序号</th><th>构造函数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>public String()</td><td>构造空字符String对象</td></tr><tr><td>2</td><td>public String(String original)</td><td>构造一个新的相同的String对象</td></tr><tr><td>3</td><td>public String(char value[])</td><td>通过给定字符数组，构造String对象</td></tr><tr><td>4</td><td>public String(char value[], int offset, int count)</td><td>给定字符数组，通过下标偏移量（offset），截取量（count）截取子数组，构建包含此子数组的String对象</td></tr><tr><td>5</td><td>String(int[] codePoints, int offset, int count)</td><td>给定int数组，通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象</td></tr><tr><td>6</td><td>public String(byte bytes[])</td><td>使用平台默认的字符集解码指定的byte数组，构造String 对象</td></tr><tr><td>7</td><td>public String(byte bytes[], int offset, int length)</td><td>通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象</td></tr><tr><td>8</td><td>public String(byte bytes[], String charsetName)</td><td>通过字符集名字（charsetName）确定字符集，然后利用此字符集解码指定的byte数组，构建String对象</td></tr><tr><td>9</td><td>public String(byte bytes[], int offset, int length, String charsetName)</td><td>通过下标偏移位置（offset），截取量（count）截取子数组，通过字符集名字确定字符集，利用此字符集解码指定的byte子数组，构建String对象</td></tr><tr><td>10</td><td>public String(byte bytes[], Charset charset)</td><td>利用字符集charset解码指定的byte数组，构建String对象；jdk1.6新增</td></tr><tr><td>11</td><td>public String(byte bytes[], int offset, int length, Charset charset)</td><td>通过下标偏移位置（offset），截取量（count）截取子数组，然后利用字符集charset解码指定的byte子数组，构建String对象；jdk1.6新增</td></tr><tr><td>12</td><td>public String(StringBuffer buffer)</td><td>通过给定的StringBuffer，构建String对象</td></tr><tr><td>13</td><td>public String(StringBuilder builder)</td><td>通过给定的StringBuffer，构建String对象</td></tr></tbody></table><h1 id="2、常见的String方法函数"><a href="#2、常见的String方法函数" class="headerlink" title="2、常见的String方法函数"></a>2、常见的String方法函数</h1><table><thead><tr><th>序号</th><th>方法函数</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>public int length()</td><td>获取字符串长度</td></tr><tr><td>2</td><td>public boolean isEmpty()</td><td>判断字符串是否为空</td></tr><tr><td>3</td><td>public char charAt(int index))</td><td>获取下标index下的字符</td></tr><tr><td>4</td><td>public byte[] getBytes()</td><td>将字符串转换成字节数组</td></tr><tr><td>5</td><td>public byte[] getBytes(String charsetName)</td><td>通过指定字符集名字将字符串转换成字节数组</td></tr><tr><td>6</td><td>public byte[] getBytes(Charset charset))</td><td>通过指定字符集将字符串转换成字节数组</td></tr><tr><td>7</td><td>public boolean equals(Object anObject)</td><td>判断两个对象中字符是否都相同</td></tr><tr><td>8</td><td>public boolean contentEquals(StringBuffer sb))</td><td>判断字符串对象和StringBuffer中内容是否相同</td></tr><tr><td>9</td><td>public boolean equalsIgnoreCase(String anotherString)</td><td>判断与另一个给定的字符串对象忽略大小写后的内容是否相同</td></tr><tr><td>10</td><td>public int compareTo(String anotherString)</td><td>与另一个字符串对象比较大小</td></tr><tr><td>11</td><td>public int indexOf(String str)</td><td>查找指定子串在字符串中第一次出现的位置下标</td></tr><tr><td>12</td><td>public int indexOf(String str, int fromIndex)</td><td>指定从起始下标位置开始查找指定子串在字符串中第一次出现的位置下标</td></tr><tr><td>13</td><td>public String substring(int beginIndex)</td><td>截取从起始下标位置开始到字符串末尾的子串</td></tr><tr><td>14</td><td>public String substring(int beginIndex, int endIndex)</td><td>截取从起始下标位置开始到（结束下标位置-1）的子串</td></tr><tr><td>15</td><td>public String concat(String str)</td><td>两个字符串拼接</td></tr><tr><td>16</td><td>public String replace(char oldChar, char newChar)</td><td>用newChar替换字符串中出现的oldChar</td></tr><tr><td>17</td><td>public boolean matches(String regex)</td><td>正则表达式匹配，匹配成功返回true，匹配失败返回false</td></tr><tr><td>18</td><td>public String[] split(String regex)</td><td>字符串在regex出现的地方进行分割，转换成字符串数组</td></tr><tr><td>19</td><td>public String[] split(String regex, int limit)</td><td>字符串在regex出现的地方进行分割，limit为分割的次数，分割成字符串数组，长度=limit+1</td></tr><tr><td>20</td><td>public String toLowerCase()</td><td>字符串中大写字母全部变成小写字母</td></tr><tr><td>21</td><td>public String toUpperCase()</td><td>字符串中小写字母全部变成大写字母</td></tr><tr><td>22</td><td>public String trim()</td><td>去除字符串首尾两端的空白字符</td></tr><tr><td>23</td><td>public char[] toCharArray()</td><td>字符串转化成字符数组</td></tr><tr><td>24</td><td>public static String valueOf(Object obj)</td><td>其他对象转化成字符串，静态方法，使用方式：String.valueOf(obj)</td></tr><tr><td>25</td><td>public static String join(CharSequence delimiter, CharSequence… elements)</td><td>字符串拼接，jdk1.8新增</td></tr></tbody></table><h1 id="3、-和-equals-两者之间的区别"><a href="#3、-和-equals-两者之间的区别" class="headerlink" title="3、== 和 equals 两者之间的区别"></a>3、== 和 equals 两者之间的区别</h1><h2 id="3-1、-比较"><a href="#3-1、-比较" class="headerlink" title="3.1、==比较"></a>3.1、==比较</h2><p>对于基本类型和引用类型==的作用效果是不同的：</p><pre><code>* 基本类型：比较的是值是否相同* 引用类型：比较的是引用是否相同</code></pre><h2 id="3-2、equals比较"><a href="#3-2、equals比较" class="headerlink" title="3.2、equals比较"></a>3.2、equals比较</h2><p>equals本质上就是==，只不过String类重写了equals方法，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">if (this == anObject) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">if (anObject instanceof String) &#123;</span><br><span class="line">    String anotherString = (String)anObject;</span><br><span class="line">    int n = value.length;</span><br><span class="line">    if (n == anotherString.value.length) &#123;</span><br><span class="line">char v1[] = value;</span><br><span class="line">char v2[] = anotherString.value;</span><br><span class="line">int i = 0;</span><br><span class="line">while (n-- != 0) &#123;</span><br><span class="line">    if (v1[i] != v2[i])</span><br><span class="line">return false;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中可以看出，当是引用比较的时候改成了值比较。</p><p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;hello&quot;;</span><br><span class="line">String s2 = &quot;hello&quot;;</span><br><span class="line">String s3 = new String(&quot;hello&quot;);</span><br><span class="line">System.out.println(s1 == s2);       // true</span><br><span class="line">System.out.println(s1 == s3);       // false</span><br><span class="line">System.out.println(s1.equals(s2));  // true</span><br><span class="line">System.out.println(s1.equals(s3));  // true</span><br></pre></td></tr></table></figure></p><p>字符串对象的创建过程：<br>String类在内存中管理着一个字符串常量池，池中所有相同的字符串常量只占用同一个内存空间。</p><pre><code>* String s1 = &quot;hello&quot;;执行这句代码时，程序会先看常量池中是否有“hello”这个字符串常量，如果没有就创建一个“hello”字符串对象，并且让引用s1指向这个对象；如果有，让引用s1直接指向常量池中已经存在的hello对象。* String s3 = new String(&quot;hello&quot;);而执行这句代码时，重复s1的操作，然后执行new String() ,重新在堆中开辟了一个内存空间，将常量池中的hello对象复制一份到这个内存空间中，让引用s3指向堆中这个刚创建的hello对象。</code></pre><h1 id="4、StringBuffer和StringBuilder的区别"><a href="#4、StringBuffer和StringBuilder的区别" class="headerlink" title="4、StringBuffer和StringBuilder的区别"></a>4、StringBuffer和StringBuilder的区别</h1><h2 id="4-1、相同点"><a href="#4-1、相同点" class="headerlink" title="4.1、相同点"></a>4.1、相同点</h2><pre><code>* 可增长，可改写* 提供了字符串的许多其他功能</code></pre><h2 id="4-2、不同点"><a href="#4-2、不同点" class="headerlink" title="4.2、不同点"></a>4.2、不同点</h2><pre><code>* StringBuffer是线程同步的，意味着它是线程安全的，但是牺牲了对字符串操作的性能* StringBuilder不是同步的，意味着它是线程不安全的，但是具有更快的字符串操作性能</code></pre><h1 id="5、StringJoiner类"><a href="#5、StringJoiner类" class="headerlink" title="5、StringJoiner类"></a>5、StringJoiner类</h1><p>Java开发中，有时候会遇到字符串拼接的操作，你可能会直接想到就是使用 + 这个操作符直接进行拼接，或者使用StringBuilder或者StringBuffer来实现，那么还有一种重要的拼接方式，就是Java8中提供的StringJoiner，还不了解这种拼接方式的童鞋，那我们就来共同学习一下这个字符串拼接类！</p><h2 id="5-1、StringJoiner类的构造函数"><a href="#5-1、StringJoiner类的构造函数" class="headerlink" title="5.1、StringJoiner类的构造函数"></a>5.1、StringJoiner类的构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public StringJoiner(CharSequence delimiter) &#123;</span><br><span class="line">        this(delimiter, &quot;&quot;, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public StringJoiner(CharSequence delimiter,</span><br><span class="line">                        CharSequence prefix,</span><br><span class="line">                        CharSequence suffix) &#123;</span><br><span class="line">        Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;);</span><br><span class="line">        Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;);</span><br><span class="line">        Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;);</span><br><span class="line">        // make defensive copies of arguments</span><br><span class="line">        this.prefix = prefix.toString();</span><br><span class="line">        this.delimiter = delimiter.toString();</span><br><span class="line">        this.suffix = suffix.toString();</span><br><span class="line">        this.emptyValue = this.prefix + this.suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringJoiner类共有上面2个构造函数，从上面可以看出，第一个构造函数就是调用第二个构造函数，那么我们就来分析一下第二个构造函数，其中delimiter这个参数表示字符串进行拼接的时候以delimiter作为分隔符，prefix代表字符串拼接后的前缀，suffix代表字符串拼接后的后缀。</p><p>StringJoiner的用法比较简单</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestJoiner &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">StringJoiner sJoiner = new StringJoiner(&quot;,&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;);</span><br><span class="line">sJoiner.add(&quot;hello&quot;);</span><br><span class="line">sJoiner.add(&quot;world&quot;);</span><br><span class="line">System.out.println(sJoiner.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;hello,world&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、常用的add方法"><a href="#5-2、常用的add方法" class="headerlink" title="5.2、常用的add方法"></a>5.2、常用的add方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public StringJoiner add(CharSequence newElement) &#123;</span><br><span class="line">        prepareBuilder().append(newElement);</span><br><span class="line">        return this;</span><br><span class="line">&#125;</span><br><span class="line">private StringBuilder prepareBuilder() &#123;</span><br><span class="line">        if (value != null) &#123;</span><br><span class="line">            value.append(delimiter);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value = new StringBuilder().append(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringJoiner其实就是依赖StringBuilder实现的</p><p>看到这，有些童鞋可能会产生一个疑问，不是已经有StringBuilder了，为什么Java8中还要定义一个StringJoiner呢？</p><p>现在有一个需求：如果我们有这样一个List，这个List中呢，有“hello”，“world”，</p><p>想要把它拼接成一个以下形式的字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello:world</span><br></pre></td></tr></table></figure><p>方式一：使用StringBuilder实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = new StringBuilder();</span><br><span class="line">if(!list.isEmpty()) &#123;</span><br><span class="line">builder.append(list.get(0));</span><br><span class="line">for (int i = 1; i &lt; list.size(); i++) &#123;</span><br><span class="line">builder.append(&quot;:&quot;).append(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(builder.toString());</span><br></pre></td></tr></table></figure><p>方式二：使用stream()实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().reduce(new StringBuilder(),(sb, s)-&gt;sb.append(s).append(&quot;:&quot;),StringBuilder::append).toString();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello:world:</span><br></pre></td></tr></table></figure><p>这种方式需要进行二次处理</p><p>方式三：使用操作符+实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String sum_string = &quot;&quot;;</span><br><span class="line">if(!list.isEmpty()) &#123;</span><br><span class="line">sum_string += list.get(0);</span><br><span class="line">for (int i = 1; i &lt; list.size(); i++) &#123;</span><br><span class="line">sum_string +=&quot;:&quot;+list.get(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum_string);</span><br></pre></td></tr></table></figure><p>以上几种方式，要么是代码复杂，要么是性能不高。</p><p>如果使用StringJoiner，一行代码就可以搞定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.joining(&quot;:&quot;));</span><br></pre></td></tr></table></figure><p>其中，Collectors.joining()的源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123;</span><br><span class="line">        return joining(delimiter, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                             CharSequence prefix,</span><br><span class="line">                                                             CharSequence suffix) &#123;</span><br><span class="line">        return new CollectorImpl&lt;&gt;(</span><br><span class="line">                () -&gt; new StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">                StringJoiner::add, StringJoiner::merge,</span><br><span class="line">                StringJoiner::toString, CH_NOID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>joining方法的实现原理就是借助了StringJoiner。</p><p>如果改变需求，在拼接后的字符串添加前缀“{”，和后缀“}”，那么StringJoiner的优势就会很明显了。</p><p>需要注意的一点是：</p><blockquote><p>StringJoiner是通过StringBuilder实现的，也就是说它也是非线程安全的。</p></blockquote><p>日常开发中，需要进行字符串拼接，如何选择？</p><pre><code>* 如果是简单字符串拼接，直接使用+即可* 如果是在for循环中进行字符串拼接，考虑使用StringBuilder或者StringBuffer。* 如果是通过一个集合，例如list，进行拼接考虑使用StringJoiner</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>字符串在Java开发中应用非常广泛，熟练掌握能避免一些不必要的坑！</p><h1 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a>寄语</h1><p>希望这篇文章能给大家带来一点帮助，如果文章中有哪些错误之处，还请批评指正！<br>我的口号是：我分享，我快乐，越分享，越快乐！<br>感谢各位老铁的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/u=1739492202,3928764710&amp;amp;fm=26&amp;amp;gp=0.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhifeiyuntian.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://zhifeiyuntian.com/tags/Java/"/>
    
      <category term="String" scheme="http://zhifeiyuntian.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>第一次总结</title>
    <link href="http://zhifeiyuntian.com/2019/03/05/interview/"/>
    <id>http://zhifeiyuntian.com/2019/03/05/interview/</id>
    <published>2019-03-05T07:32:33.000Z</published>
    <updated>2019-03-18T05:34:03.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/timg.jpg?raw=true" alt="首次总结" title="首次总结"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。</p><p><hr><br><a id="more"></a></p><h1 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h1><hr><p>学习了一些新技能：</p><pre><code>*  熟悉了Markdown语法*  利用阿里云解析了GitHub和coding里的Pages服务*  HEXO和主题配置</code></pre><hr><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><hr><h2 id="站点配置文件-config-yml："><a href="#站点配置文件-config-yml：" class="headerlink" title="站点配置文件_config.yml："></a>站点配置文件_config.yml：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">#RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  #type: git</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:MrWhiteSike/MrWhiteSike.github.io.git,master</span><br><span class="line">    coding: git@git.coding.net:MrWhiteSike/MrWhiteSike.git,master</span><br></pre></td></tr></table></figure><h2 id="主题配置文件-themes-next-config-yml"><a href="#主题配置文件-themes-next-config-yml" class="headerlink" title="主题配置文件/themes/next/_config.yml:"></a>主题配置文件/themes/next/_config.yml:</h2><p>参考了<a href="https://blog.csdn.net/qq_32454537/article/details/79482896" title="这篇博文" target="_blank" rel="noopener">这篇博文</a>，具体配置细节还请自己琢磨</p><hr><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr><p>做这个博客呢，愿景有二：</p><pre><code>* 记录生活中的点滴故事* 分享知识，提升技能</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/timg.jpg?raw=true&quot; alt=&quot;首次总结&quot; title=&quot;首次总结&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;hr&gt;

&lt;p&gt;创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。&lt;/p&gt;
&lt;p&gt;&lt;hr&gt;&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://zhifeiyuntian.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="生活" scheme="http://zhifeiyuntian.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>开篇博客</title>
    <link href="http://zhifeiyuntian.com/2019/03/01/firstpaper/"/>
    <id>http://zhifeiyuntian.com/2019/03/01/firstpaper/</id>
    <published>2019-03-01T00:26:29.000Z</published>
    <updated>2019-03-18T08:00:36.575Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/MrWhiteSike/images/blob/master/u=1620388557,1868393758&amp;fm=26&amp;gp=0.jpg?raw=true" alt="Markdown"></p><center>开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！</center><a id="more"></a><p>大概花了几天时间利用HEXO框架搭建了这个博客，建好之后心情还有点小激动，毕竟经过自己的一番努力，终于实现拥有专属于自己的个人博客网站，这里参考了<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029#t18" title="hexo史上最全搭建教程" target="_blank" rel="noopener">hexo史上最全搭建教程</a>，感谢这篇文章的博主，写的如此清晰，才让我如此快速的搭建起个人博客网站。</p><p>俗话说：万事开头难。但是只要相信，勇于实践，锲而不舍，方能成功。只要开始，我们不可半途而废，越过山丘，我们才能看到山后的另一番景象！</p><p>先写这么多吧，来日方长！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/MrWhiteSike/images/blob/master/u=1620388557,1868393758&amp;amp;fm=26&amp;amp;gp=0.jpg?raw=true&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;
&lt;center&gt;开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！&lt;/center&gt;
    
    </summary>
    
      <category term="生活" scheme="http://zhifeiyuntian.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://zhifeiyuntian.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
