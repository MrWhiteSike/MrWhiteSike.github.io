<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础 （一）字符串]]></title>
    <url>%2F2019%2F03%2F06%2Fstring%2F</url>
    <content type="text"><![CDATA[前言字符串广泛应用在Java编程中，JDK中提供了String类来创建和操作字符串对象。当创建了一个String对象后，所创建的字符串是不能改变的，在需要使用可修改的字符串时，Java提供了两个选择：StringBuffer和StringBuilder。在JDK1.8中又添加了新成员StringJoiner类，在这里也写一下这个类具体用法。 1、String构造函数 序号 构造函数 说明 1 public String() 构造空字符String对象 2 public String(String original) 构造一个新的相同的String对象 3 public String(char value[]) 通过给定字符数组，构造String对象 4 public String(char value[], int offset, int count) 给定字符数组，通过下标偏移量（offset），截取量（count）截取子数组，构建包含此子数组的String对象 5 String(int[] codePoints, int offset, int count) 给定int数组，通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 6 public String(byte bytes[]) 使用平台默认的字符集解码指定的byte数组，构造String 对象 7 public String(byte bytes[], int offset, int length) 通过下标偏移位置（offset），截取量（count）截取子数组，构建包含此子数组的String对象 8 public String(byte bytes[], String charsetName) 通过字符集名字（charsetName）确定字符集，然后利用此字符集解码指定的byte数组，构建String对象 9 public String(byte bytes[], int offset, int length, String charsetName) 通过下标偏移位置（offset），截取量（count）截取子数组，通过字符集名字确定字符集，利用此字符集解码指定的byte子数组，构建String对象 10 public String(byte bytes[], Charset charset) 利用字符集charset解码指定的byte数组，构建String对象；jdk1.6新增 11 public String(byte bytes[], int offset, int length, Charset charset) 通过下标偏移位置（offset），截取量（count）截取子数组，然后利用字符集charset解码指定的byte子数组，构建String对象；jdk1.6新增 12 public String(StringBuffer buffer) 通过给定的StringBuffer，构建String对象 13 public String(StringBuilder builder) 通过给定的StringBuffer，构建String对象 2、常见的String方法函数 序号 方法函数 说明 1 public int length() 获取字符串长度 2 public boolean isEmpty() 判断字符串是否为空 3 public char charAt(int index)) 获取下标index下的字符 4 public byte[] getBytes() 将字符串转换成字节数组 5 public byte[] getBytes(String charsetName) 通过指定字符集名字将字符串转换成字节数组 6 public byte[] getBytes(Charset charset)) 通过指定字符集将字符串转换成字节数组 7 public boolean equals(Object anObject) 判断两个对象中字符是否都相同 8 public boolean contentEquals(StringBuffer sb)) 判断字符串对象和StringBuffer中内容是否相同 9 public boolean equalsIgnoreCase(String anotherString) 判断与另一个给定的字符串对象忽略大小写后的内容是否相同 10 public int compareTo(String anotherString) 与另一个字符串对象比较大小 11 public int indexOf(String str) 查找指定子串在字符串中第一次出现的位置下标 12 public int indexOf(String str, int fromIndex) 指定从起始下标位置开始查找指定子串在字符串中第一次出现的位置下标 13 public String substring(int beginIndex) 截取从起始下标位置开始到字符串末尾的子串 14 public String substring(int beginIndex, int endIndex) 截取从起始下标位置开始到（结束下标位置-1）的子串 15 public String concat(String str) 两个字符串拼接 16 public String replace(char oldChar, char newChar) 用newChar替换字符串中出现的oldChar 17 public boolean matches(String regex) 正则表达式匹配，匹配成功返回true，匹配失败返回false 18 public String[] split(String regex) 字符串在regex出现的地方进行分割，转换成字符串数组 19 public String[] split(String regex, int limit) 字符串在regex出现的地方进行分割，limit为分割的次数，分割成字符串数组，长度=limit+1 20 public String toLowerCase() 字符串中大写字母全部变成小写字母 21 public String toUpperCase() 字符串中小写字母全部变成大写字母 22 public String trim() 去除字符串首尾两端的空白字符 23 public char[] toCharArray() 字符串转化成字符数组 24 public static String valueOf(Object obj) 其他对象转化成字符串，静态方法，使用方式：String.valueOf(obj) 25 public static String join(CharSequence delimiter, CharSequence… elements) 字符串拼接，jdk1.8新增 3、== 和 equals 两者之间的区别3.1、==比较对于基本类型和引用类型==的作用效果是不同的： * 基本类型：比较的是值是否相同 * 引用类型：比较的是引用是否相同 3.2、equals比较equals本质上就是==，只不过String类重写了equals方法，源码如下：123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 从源码中可以看出，当是引用比较的时候改成了值比较。 示例代码：1234567String s1 = &quot;hello&quot;;String s2 = &quot;hello&quot;;String s3 = new String(&quot;hello&quot;);System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // falseSystem.out.println(s1.equals(s2)); // trueSystem.out.println(s1.equals(s3)); // true 字符串对象的创建过程：String类在内存中管理着一个字符串常量池，池中所有相同的字符串常量只占用同一个内存空间。 * String s1 = &quot;hello&quot;;执行这句代码时，程序会先看常量池中是否有“hello”这个字符串常量，如果没有就创建一个“hello”字符串对象，并且让引用s1指向这个对象；如果有，让引用s1直接指向常量池中已经存在的hello对象。 * String s3 = new String(&quot;hello&quot;);而执行这句代码时，重复s1的操作，然后执行new String() ,重新在堆中开辟了一个内存空间，将常量池中的hello对象复制一份到这个内存空间中，让引用s3指向堆中这个刚创建的hello对象。 4、StringBuffer和StringBuilder的区别4.1、相同点* 可增长，可改写 * 提供了字符串的许多其他功能 4.2、不同点* StringBuffer是线程同步的，意味着它是线程安全的，但是牺牲了对字符串操作的性能 * StringBuilder不是同步的，意味着它是线程不安全的，但是具有更快的字符串操作性能 5、StringJoiner类Java开发中，有时候会遇到字符串拼接的操作，你可能会直接想到就是使用 + 这个操作符直接进行拼接，或者使用StringBuilder或者StringBuffer来实现，那么还有一种重要的拼接方式，就是Java8中提供的StringJoiner，还不了解这种拼接方式的童鞋，那我们就来共同学习一下这个字符串拼接类！ 5.1、StringJoiner类的构造函数12345678910111213141516public StringJoiner(CharSequence delimiter) &#123; this(delimiter, &quot;&quot;, &quot;&quot;);&#125;public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; Objects.requireNonNull(prefix, &quot;The prefix must not be null&quot;); Objects.requireNonNull(delimiter, &quot;The delimiter must not be null&quot;); Objects.requireNonNull(suffix, &quot;The suffix must not be null&quot;); // make defensive copies of arguments this.prefix = prefix.toString(); this.delimiter = delimiter.toString(); this.suffix = suffix.toString(); this.emptyValue = this.prefix + this.suffix;&#125; StringJoiner类共有上面2个构造函数，从上面可以看出，第一个构造函数就是调用第二个构造函数，那么我们就来分析一下第二个构造函数，其中delimiter这个参数表示字符串进行拼接的时候以delimiter作为分隔符，prefix代表字符串拼接后的前缀，suffix代表字符串拼接后的后缀。 StringJoiner的用法比较简单 示例代码： 12345678public class TestJoiner &#123; public static void main(String[] args) &#123; StringJoiner sJoiner = new StringJoiner(&quot;,&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;); sJoiner.add(&quot;hello&quot;); sJoiner.add(&quot;world&quot;); System.out.println(sJoiner.toString()); &#125;&#125; 以上代码输出结果： 1&#123;hello,world&#125; 5.2、常用的add方法123456789101112public StringJoiner add(CharSequence newElement) &#123; prepareBuilder().append(newElement); return this;&#125;private StringBuilder prepareBuilder() &#123; if (value != null) &#123; value.append(delimiter); &#125; else &#123; value = new StringBuilder().append(prefix); &#125; return value;&#125; StringJoiner其实就是依赖StringBuilder实现的 看到这，有些童鞋可能会产生一个疑问，不是已经有StringBuilder了，为什么Java8中还要定义一个StringJoiner呢？ 现在有一个需求：如果我们有这样一个List，这个List中呢，有“hello”，“world”， 想要把它拼接成一个以下形式的字符串： 1hello:world 方式一：使用StringBuilder实现 12345678StringBuilder builder = new StringBuilder();if(!list.isEmpty()) &#123; builder.append(list.get(0)); for (int i = 1; i &lt; list.size(); i++) &#123; builder.append(&quot;:&quot;).append(list.get(i)); &#125;&#125;System.out.println(builder.toString()); 方式二：使用stream()实现 1list.stream().reduce(new StringBuilder(),(sb, s)-&gt;sb.append(s).append(&quot;:&quot;),StringBuilder::append).toString(); 输出结果： 1hello:world: 这种方式需要进行二次处理 方式三：使用操作符+实现 12345678String sum_string = &quot;&quot;;if(!list.isEmpty()) &#123; sum_string += list.get(0); for (int i = 1; i &lt; list.size(); i++) &#123; sum_string +=&quot;:&quot;+list.get(i); &#125;&#125;System.out.println(sum_string); 以上几种方式，要么是代码复杂，要么是性能不高。 如果使用StringJoiner，一行代码就可以搞定： 1list.stream().collect(Collectors.joining(&quot;:&quot;)); 其中，Collectors.joining()的源代码： 1234567891011public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123; return joining(delimiter, &quot;&quot;, &quot;&quot;); &#125;public static Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix) &#123; return new CollectorImpl&lt;&gt;( () -&gt; new StringJoiner(delimiter, prefix, suffix), StringJoiner::add, StringJoiner::merge, StringJoiner::toString, CH_NOID); &#125; joining方法的实现原理就是借助了StringJoiner。 如果改变需求，在拼接后的字符串添加前缀“{”，和后缀“}”，那么StringJoiner的优势就会很明显了。 需要注意的一点是： StringJoiner是通过StringBuilder实现的，也就是说它也是非线程安全的。 日常开发中，需要进行字符串拼接，如何选择？ * 如果是简单字符串拼接，直接使用+即可 * 如果是在for循环中进行字符串拼接，考虑使用StringBuilder或者StringBuffer。 * 如果是通过一个集合，例如list，进行拼接考虑使用StringJoiner 总结字符串在Java开发中应用非常广泛，熟练掌握能避免一些不必要的坑！希望能给大家带来一点帮助，如果文章中有哪些错误之处，还请批评指正！我的口号是：我分享，我快乐，越分享，越快乐！ 感谢各位老铁的支持。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次总结]]></title>
    <url>%2F2019%2F03%2F05%2Finterview%2F</url>
    <content type="text"><![CDATA[前言 创建了博客好几天了，现在才来更新，看来我这拖延症又犯了啊。。。 进步 学习了一些新技能： * 熟悉了Markdown语法 * 利用阿里云解析了GitHub和coding里的Pages服务 * HEXO和主题配置 主题配置 站点配置文件_config.yml：123456789101112131415161718192021222324252627282930313233343536373839# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/# 搜索search: path: search.xml field: post format: html limit: 10000#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #type: git type: git repo: github: git@github.com:MrWhiteSike/MrWhiteSike.github.io.git,master coding: git@git.coding.net:MrWhiteSike/MrWhiteSike.git,master 主题配置文件/themes/next/_config.yml:参考了这篇博文，具体配置细节还请自己琢磨 结束 做这个博客呢，愿景有二： * 记录生活中的点滴故事 * 分享知识，提升技能]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇博客]]></title>
    <url>%2F2019%2F03%2F01%2Ffirstpaper%2F</url>
    <content type="text"><![CDATA[开通个人博客，写些东西。在成长的路上，留作纪念，岂不乐哉！ 大概花了几天时间利用HEXO框架搭建了这个博客，建好之后心情还有点小激动，毕竟经过自己的一番努力，终于实现拥有专属于自己的个人博客网站，这里参考了hexo史上最全搭建教程，感谢这篇文章的博主，写的如此清晰，才让我如此快速的搭建起个人博客网站。 俗话说：万事开头难。但是只要相信，勇于实践，锲而不舍，方能成功。只要开始，我们不可半途而废，越过山丘，我们才能看到山后的另一番景象！ 先写这么多吧，来日方长！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
